#define MASTER_ID_TRCH_CPU  0x2d

#define MASTER_ID_RTPS_CPU0 0x2e
#define MASTER_ID_RTPS_CPU1 0x2f

#define MASTER_ID_HPPS_CPU0 0x80
#define MASTER_ID_HPPS_CPU1 0x8d
#define MASTER_ID_HPPS_CPU2 0x8e
#define MASTER_ID_HPPS_CPU3 0x8f
#define MASTER_ID_HPPS_CPU4 0x90
#define MASTER_ID_HPPS_CPU5 0x9d
#define MASTER_ID_HPPS_CPU6 0x9e
#define MASTER_ID_HPPS_CPU7 0x9f

#define MASTER_ID_XGMAC     0x874
#define MASTER_ID_TRCH_DMA  0x875
#define MASTER_ID_RTPS_DMA  0x876
#define MASTER_ID_HPPS_DMA  0x877
#define MASTER_ID_SRIO0_DMA 0x878
#define MASTER_ID_SRIO1_DMA 0x879

/* TODO: renumber IRQs */

#define NAND_IRQ_0			 14

#define LSIO_UART0_IRQ_0		 21
#define LSIO_UART1_IRQ_0		 22
#define HPPS_UART0_IRQ_0		 23

#define XGMAC_IRQ_0			 57
#define XGMAC_IRQ_1_WAKE		 58

#define TRCH_DMA_ABORT_IRQ		59
#define TRCH_DMA_EV0_IRQ		60
#define RTPS_DMA_ABORT_IRQ		61
#define RTPS_DMA_EV0_IRQ		62
#define HPPS_DMA_ABORT_IRQ		63
#define HPPS_DMA_EV0_IRQ		64
#define SRIO0_DMA_ABORT_IRQ		65
#define SRIO0_DMA_EV0_IRQ		66
#define SRIO1_DMA_ABORT_IRQ		67
#define SRIO1_DMA_EV0_IRQ		68

#define RTPS_SMMU_IRQ			69
#define HPPS_SMMU0_IRQ			70
#define HPPS_SMMU1_IRQ			71

/* #define TRCH_MAILBOX_IRQs  	        72-87 */
/* #define HPPS_TRCH_MAILBOX_IRQs  	136-151 */
/* #define HPPS_SMMU_GLOB_IRQ           152 */
/* #define HPPS_SMMU_CB_IRQ             153-168 */
/* #define RT_SMMU_GLOB_IRQ             169 */
/* #define RT_SMMU_CB_IRQ               170-185 */
/* #define RTPS_SMMU_GLOB_IRQ           186 */
/* #define RTPS_SMMU_CB_IRQ             187-202 */
/* #define HPPS_RTPS_MAILBOX_IRQs  	203-218 */

#if 0 /* TODO: check if used before adding */
#define CRL_int_IRQ_0				11
#define TRCH_IPI0_IRQ_0				12
#define RPU_IPI0_IRQ_0				33
#define RPU_IPI1_IRQ_0				34
#endif
#define APU_IPI0_IRQ_0				35

/* TODO: The secondary CPU entry point is normally set by PSCI
   code at time of reset request (also, the PSCI code uses the symbol instead
   of a raw address). However, the setting of rvbar CPU property is currently
   broken; so, for now, we define the entry point here. */
#define HPPS_RESET_ADDR_PRIMARY_CPU   0xfffda000 /* ATF bl31_entrypoint */
#define HPPS_RESET_ADDR_SECONDARY_CPU 0xfffda110 /* ATF bl31_warm_entrypoint */

/dts-v1/;

/ {
    #address-cells = <1>;
    #size-cells = <1>;
    #priority-cells = <1>;
    #interrupt-cells = <1>;

    /* We have to use a map, as opposed to the 'interrupt' property on each
       device if an interrupt might be connected to more than one interrupt
       controller. There's no way to specify that case with the 'interrupt'
       property alone, afaik.

       Also, we define the map in the root node, because the mappings must
       apply to devices spread around different branches of the tree.

       For now, the map is such that interrupt with ID N is mapped to the
       controller input number N. AFAIU, the interrupt controller input
       number has a correspondence to real HW, however the interrupt ID
       has meaning only inside this device tree definition.
    */
    interrupt-map-mask = <0x0 0x0 0xffff>;	/* 0 0 (don't know) 0xffff (IRQ#) */
    interrupt-map = 
      /* specifier for device interrupt (#cells=3, hardcoded/assumed in Qemu):
         unused unused int#  */
        /*                       TRCH                                          */
        /* 3-cell int specifier      int ctrl  ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 CRL_int_IRQ_0           &trch_nvic 0 CRL_int_IRQ_0           4>,
        <0 0 TRCH_IPI0_IRQ_0         &trch_nvic 0 TRCH_IPI0_IRQ_0         4>,
#endif
        /* LSIO mailbox */
        <0 0 72 &trch_nvic 0 72 4>, <0 0 73 &trch_nvic 0 73 4>,
        <0 0 74 &trch_nvic 0 74 4>, <0 0 75 &trch_nvic 0 75 4>,
        <0 0 76 &trch_nvic 0 76 4>, <0 0 77 &trch_nvic 0 77 4>,
        <0 0 78 &trch_nvic 0 78 4>, <0 0 79 &trch_nvic 0 79 4>,
        <0 0 80 &trch_nvic 0 80 4>, <0 0 81 &trch_nvic 0 81 4>,
        <0 0 82 &trch_nvic 0 82 4>, <0 0 83 &trch_nvic 0 83 4>,
        <0 0 84 &trch_nvic 0 84 4>, <0 0 85 &trch_nvic 0 85 4>,
        <0 0 86 &trch_nvic 0 86 4>, <0 0 87 &trch_nvic 0 87 4>,

        /* HPPS-TRCH mailbox */
        <0 0 136 &trch_nvic 0 136 4>, <0 0 137 &trch_nvic 0 137 4>,
        <0 0 138 &trch_nvic 0 138 4>, <0 0 139 &trch_nvic 0 139 4>,
        <0 0 140 &trch_nvic 0 140 4>, <0 0 141 &trch_nvic 0 141 4>,
        <0 0 142 &trch_nvic 0 142 4>, <0 0 143 &trch_nvic 0 143 4>,
        <0 0 144 &trch_nvic 0 144 4>, <0 0 145 &trch_nvic 0 145 4>,
        <0 0 146 &trch_nvic 0 146 4>, <0 0 147 &trch_nvic 0 147 4>,
        <0 0 148 &trch_nvic 0 148 4>, <0 0 149 &trch_nvic 0 149 4>,
        <0 0 150 &trch_nvic 0 150 4>, <0 0 151 &trch_nvic 0 151 4>,

        /* RTPS/TRCH->HPPS (RT) SMMU */
        <0 0 169 &trch_nvic 0 169 4>,
        <0 0 170 &trch_nvic 0 170 4>, <0 0 171 &trch_nvic 0 171 4>,
        <0 0 172 &trch_nvic 0 172 4>, <0 0 173 &trch_nvic 0 173 4>,
        <0 0 174 &trch_nvic 0 174 4>, <0 0 175 &trch_nvic 0 175 4>,
        <0 0 176 &trch_nvic 0 176 4>, <0 0 177 &trch_nvic 0 177 4>,
        <0 0 178 &trch_nvic 0 178 4>, <0 0 179 &trch_nvic 0 179 4>,
        <0 0 180 &trch_nvic 0 180 4>, <0 0 181 &trch_nvic 0 181 4>,
        <0 0 182 &trch_nvic 0 182 4>, <0 0 183 &trch_nvic 0 183 4>,
        <0 0 184 &trch_nvic 0 184 4>, <0 0 185 &trch_nvic 0 185 4>,

        <0 0 TRCH_DMA_ABORT_IRQ      &trch_nvic 0 TRCH_DMA_ABORT_IRQ        4>,
        <0 0 TRCH_DMA_EV0_IRQ        &trch_nvic 0 TRCH_DMA_EV0_IRQ          4>,

        /*                       RTPS                                          */
        /* 3-cell int specifier      int ctrl   ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 RPU_IPI0_IRQ_0          &rtps_gic 0 RPU_IPI0_IRQ_0          4>,
        <0 0 RPU_IPI1_IRQ_0          &rtps_gic 0 RPU_IPI1_IRQ_0          4>,
#endif
        /* LSIO mailbox */
        <0 0 72 &rtps_gic 0 72 4>, <0 0 73 &rtps_gic 0 73 4>,
        <0 0 74 &rtps_gic 0 74 4>, <0 0 75 &rtps_gic 0 75 4>,
        <0 0 76 &rtps_gic 0 76 4>, <0 0 77 &rtps_gic 0 77 4>,
        <0 0 78 &rtps_gic 0 78 4>, <0 0 79 &rtps_gic 0 79 4>,
        <0 0 80 &rtps_gic 0 80 4>, <0 0 81 &rtps_gic 0 81 4>,
        <0 0 82 &rtps_gic 0 82 4>, <0 0 83 &rtps_gic 0 83 4>,
        <0 0 84 &rtps_gic 0 84 4>, <0 0 85 &rtps_gic 0 85 4>,
        <0 0 86 &rtps_gic 0 86 4>, <0 0 87 &rtps_gic 0 87 4>,

        /* HPPS-RTPS mailbox */
        <0 0 203 &rtps_gic 0 203 4>, <0 0 204 &rtps_gic 0 204 4>,
        <0 0 205 &rtps_gic 0 205 4>, <0 0 206 &rtps_gic 0 206 4>,
        <0 0 207 &rtps_gic 0 207 4>, <0 0 208 &rtps_gic 0 208 4>,
        <0 0 209 &rtps_gic 0 209 4>, <0 0 210 &rtps_gic 0 210 4>,
        <0 0 211 &rtps_gic 0 211 4>, <0 0 212 &rtps_gic 0 212 4>,
        <0 0 213 &rtps_gic 0 213 4>, <0 0 214 &rtps_gic 0 214 4>,
        <0 0 215 &rtps_gic 0 215 4>, <0 0 216 &rtps_gic 0 216 4>,
        <0 0 217 &rtps_gic 0 217 4>, <0 0 218 &rtps_gic 0 218 4>,

        /* RTPS SMMU */
        <0 0 186 &rtps_gic 0 186 4>,
        <0 0 187 &rtps_gic 0 187 4>, <0 0 188 &rtps_gic 0 188 4>,
        <0 0 189 &rtps_gic 0 155 4>, <0 0 189 &rtps_gic 0 189 4>,
        <0 0 190 &rtps_gic 0 157 4>, <0 0 191 &rtps_gic 0 191 4>,
        <0 0 192 &rtps_gic 0 192 4>, <0 0 193 &rtps_gic 0 193 4>,
        <0 0 194 &rtps_gic 0 194 4>, <0 0 195 &rtps_gic 0 195 4>,
        <0 0 196 &rtps_gic 0 196 4>, <0 0 197 &rtps_gic 0 197 4>,
        <0 0 198 &rtps_gic 0 198 4>, <0 0 199 &rtps_gic 0 199 4>,
        <0 0 200 &rtps_gic 0 200 4>, <0 0 201 &rtps_gic 0 202 4>,

        <0 0 RTPS_DMA_ABORT_IRQ      &rtps_gic 0 RTPS_DMA_ABORT_IRQ     4>,
        <0 0 RTPS_DMA_EV0_IRQ        &rtps_gic 0 RTPS_DMA_EV0_IRQ       4>,

        /*                       HPPS                                          */
        /* 3-cell int specifier      int ctrl   ? input #              int type  */ 
#if 0 /* check how these are used before adding */
        <0 0 CRF_int_IRQ_0           &hpps_gic  0 CRF_int_IRQ_0           4>,
        <0 0 RPU_IPI1_IRQ_0          &hpps_gic  0 RPU_IPI1_IRQ_0          4>,
#endif
        /* needed by ATF PSCI code */
        <0 0 APU_IPI0_IRQ_0          &hpps_gic  0 APU_IPI0_IRQ_0          4>,

        <0 0 NAND_IRQ_0 	     &hpps_gic  0 NAND_IRQ_0		  4>,

        /* HPPS-TRCH mailbox */
        <0 0 136 &hpps_gic 0 136 4>, <0 0 137 &hpps_gic 0 137 4>,
        <0 0 138 &hpps_gic 0 138 4>, <0 0 139 &hpps_gic 0 139 4>,
        <0 0 140 &hpps_gic 0 140 4>, <0 0 141 &hpps_gic 0 141 4>,
        <0 0 142 &hpps_gic 0 142 4>, <0 0 143 &hpps_gic 0 143 4>,
        <0 0 144 &hpps_gic 0 144 4>, <0 0 145 &hpps_gic 0 145 4>,
        <0 0 146 &hpps_gic 0 146 4>, <0 0 147 &hpps_gic 0 147 4>,
        <0 0 148 &hpps_gic 0 148 4>, <0 0 149 &hpps_gic 0 149 4>,
        <0 0 150 &hpps_gic 0 150 4>, <0 0 151 &hpps_gic 0 151 4>,

        /* HPPS-RTPS mailbox */
        <0 0 203 &hpps_gic 0 203 4>, <0 0 204 &hpps_gic 0 204 4>,
        <0 0 205 &hpps_gic 0 205 4>, <0 0 206 &hpps_gic 0 206 4>,
        <0 0 207 &hpps_gic 0 207 4>, <0 0 208 &hpps_gic 0 208 4>,
        <0 0 209 &hpps_gic 0 209 4>, <0 0 210 &hpps_gic 0 210 4>,
        <0 0 211 &hpps_gic 0 211 4>, <0 0 212 &hpps_gic 0 212 4>,
        <0 0 213 &hpps_gic 0 213 4>, <0 0 214 &hpps_gic 0 214 4>,
        <0 0 215 &hpps_gic 0 215 4>, <0 0 216 &hpps_gic 0 216 4>,
        <0 0 217 &hpps_gic 0 217 4>, <0 0 218 &hpps_gic 0 218 4>,

        /* HPPS SMMU */
        <0 0 152 &hpps_gic 0 152 4>,
        <0 0 153 &hpps_gic 0 153 4>, <0 0 154 &hpps_gic 0 154 4>,
        <0 0 155 &hpps_gic 0 155 4>, <0 0 156 &hpps_gic 0 156 4>,
        <0 0 157 &hpps_gic 0 157 4>, <0 0 158 &hpps_gic 0 158 4>,
        <0 0 159 &hpps_gic 0 159 4>, <0 0 160 &hpps_gic 0 160 4>,
        <0 0 161 &hpps_gic 0 161 4>, <0 0 162 &hpps_gic 0 162 4>,
        <0 0 163 &hpps_gic 0 163 4>, <0 0 164 &hpps_gic 0 164 4>,
        <0 0 165 &hpps_gic 0 165 4>, <0 0 166 &hpps_gic 0 166 4>,
        <0 0 167 &hpps_gic 0 167 4>, <0 0 168 &hpps_gic 0 168 4>,

        <0 0 HPPS_UART0_IRQ_0        &hpps_gic  0 HPPS_UART0_IRQ_0        4>,
        <0 0 XGMAC_IRQ_0             &hpps_gic  0 XGMAC_IRQ_0             4>,
        <0 0 XGMAC_IRQ_1_WAKE        &hpps_gic  0 XGMAC_IRQ_1_WAKE        4>,
        <0 0 HPPS_DMA_ABORT_IRQ      &hpps_gic  0 HPPS_DMA_ABORT_IRQ      4>,
        <0 0 HPPS_DMA_EV0_IRQ        &hpps_gic  0 HPPS_DMA_EV0_IRQ        4>,
        <0 0 SRIO0_DMA_ABORT_IRQ     &hpps_gic  0 SRIO0_DMA_ABORT_IRQ     4>,
        <0 0 SRIO0_DMA_EV0_IRQ       &hpps_gic  0 SRIO0_DMA_EV0_IRQ       4>,
        <0 0 SRIO1_DMA_ABORT_IRQ     &hpps_gic  0 SRIO1_DMA_ABORT_IRQ     4>,
        <0 0 SRIO1_DMA_EV0_IRQ       &hpps_gic  0 SRIO1_DMA_EV0_IRQ       4>;

    cpus {
        #size-cells = <0>;
        #priority-cells = <0>;

        trch_cpus {
            trch_memattr_cpu: trch_memattr_cpu@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_TRCH_CPU>;
            };

            trch_cpu: trch_cpu {
                #address-cells = <1>;

                compatible = "cortex-m4f-arm-cpu";
                device_type = "cpu";
                reg = <0>;

                gdb-id = "TRCH Cortex-M4";

                clock-frequency = <100000000>;
                d-cache-line-size = <0x20>;            
                d-cache-size = <0x1000>;            
                i-cache-line-size = <0x20>;        
                i-cache-size = <0x200>;

                arm,midr = <0x410fc240>;
                arm,ctr = <0x83338003>;
                arm,clidr = <0x09200003>;
                arm,id_pfr0 = <0x30>;
                arm,ccsidr1 = <0x24770011>;

                timebase-frequency = <100000000>;

                mr = <&trch>;
                memory = <&trch>;
                memattr_ns = <&trch_memattr_cpu>;
                /* TODO: memattr_s, mr-secure : ? */
            };
        };

        rtps_cpus {

#define RTPS_CPU_PROPS                                 \
                #interrupt-cells = <1>;                \
                compatible = "cortex-r52f-arm-cpu";    \
                device_type = "cpu";                   \
                d-cache-line-size = <0x20>;            \
                d-cache-size = <0x8000>;               \
                i-cache-line-size = <0x20>;            \
                i-cache-size = <0x8000>;               \
                arm,midr=<0x411fd130>;                 \
                arm,tcmtr=<0x00010003>;                \
                arm,ctr=<0x8144c004>;                  \
                arm,clidr=<0x09200003>;                \
                arm,ccsidr0 = <0xf01fe019>;            \
                arm,ccsidr1 = <0xf01fe019>;            \
                arm,id_pfr0 = <0x131>;                 \
                arm,reset_sctlr = <0x30c50838>;        \
                arm,rvbar = <0x60000000>;              \
                arm,vbar = <0x60000000>;               \
                arm,cfgperiphbase = <0x28000000>;      \
                arm,buildoptr= <0x00f00000>;           \
                arm,pinoptr= <0x00000000>;             \
                arm,atcmregionr = <0x00000014>;        \
                arm,btcmregionr = <0x00004014>;        \
                arm,ctcmregionr = <0x00008014>;        \
                start-powered-off = <1>;               \

            rtps_memattr_cpu0: rtps_memattr_cpu@0 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU0>;
            };
            rtps_cpu0: rtps_cpu@0 {
                RTPS_CPU_PROPS
                reg = <0>;
                gdb-id = "RTPS Cortex-R52 #0";
                arm,mp-affinity = <0x0>;

                mr = <&rtps0>;
                memory = <&rtps0>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu0>;

                // crl 0: controller_gpios: RST_R5(0)
                // rpu_ctrl 0: controller_gpios: R5_0_HALT
                // rpu_ctrl 7:                 : wfi_in_0
                // IS_MULTI_ARCH() = nothing
                gpios = <&crl 0 &rpu_ctrl 0 &rpu_ctrl 5 >;
                gpio-names = "reset", "ncpuhalt", "vinithi";
            };

            rtps_memattr_cpu1: rtps_memattr_cpu@1 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU1>;
            };
            rtps_cpu1: rtps_cpu@1 {
                RTPS_CPU_PROPS
                reg = <1>;
                gdb-id = "RTPS Cortex-R52 #1";
                arm,mp-affinity = <0x1>;

                mr = <&rtps1>;
                memory = <&rtps1>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu1>;

                // crl 1: controller_gpios: RST_R5(1)
                // rpu_ctrl 1: controller_gpios: R5_1_HALT
                // rpu_ctrl 8:                 : wfi_in_1
                // IS_MULTI_ARCH() = nothing
                /* still, cannot find "halt" */
                gpios = <&crl 1 &rpu_ctrl 2 &rpu_ctrl 1 &rpu_ctrl 6 >;
                gpio-names = "reset", "halt", "ncpuhalt", "vinithi" ;
            };
        };

        hpps_cpus {

#define HPPS_CPU_PROPS                                    \
                #interrupt-cells = <1>;                   \
                compatible = "cortex-a53-arm-cpu";        \
                device_type = "cpu";                      \
                d-cache-line-size = <0x20>;               \
                d-cache-size = <0x8000>;                  \
                i-cache-line-size = <0x20>;               \
                i-cache-size = <0x8000>;                  \
                arm,midr = <0x410fd032>;                  \
                arm,ctr = <0x83338003>;                   \
                arm,clidr = <0x09200003>;                 \
                arm,id_pfr0 = <0x1231>;                   \
                arm,ccsidr0 = <0x701fe019>;               \
                arm,ccsidr1 = <0x201fe019>;               \
                enable-method = "psci";                   \
                arm,reset-hivecs = <1>;                   \
                arm,reset-cbar = <0xfd3fe000>;            \
                start-powered-off = <1>;                  \
                mr = <&hpps>;                             \
                memory = <&hpps>;                         \
                memory_ns = <&hpps>;                      \


            hpps_memattr_cpu0_s: hpps_memattr_cpu_s@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu0_ns: hpps_memattr_cpu_ns@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_cpu0: hpps_cpu@0 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #0";

                reg = <0>;
                arm,mp-affinity = <0>;
                arm,rvbar = <HPPS_RESET_ADDR_PRIMARY_CPU>;

                gpios = </* RESET    */ &crf 0
                         /* NCPUHALT */ &apu 4
                         /* VINITHI  */ &apu 8>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu0_s>;
                memattr_ns = <&hpps_memattr_cpu0_ns>;
            };

            hpps_memattr_cpu1_s: hpps_memattr_cpu_s@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu1_ns: hpps_memattr_cpu_ns@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU1>;
            };
            hpps_cpu1: hpps_cpu@1 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #1";

                reg = <1>;
                arm,mp-affinity = <1>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 1
                         /* NCPUHALT */ &apu 5
                         /* VINITHI  */ &apu 9>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu1_s>;
                memattr_ns = <&hpps_memattr_cpu1_ns>;
            };

            hpps_memattr_cpu2_s: hpps_memattr_cpu_s@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_memattr_cpu2_ns: hpps_memattr_cpu_ns@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_cpu2: hpps_cpu@2 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #2";

                reg = <2>;
                arm,mp-affinity = <2>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 2
                         /* NCPUHALT */ &apu 6
                         /* VINITHI  */ &apu 10>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu2_s>;
                memattr_ns = <&hpps_memattr_cpu2_ns>;
            };

            hpps_memattr_cpu3_s: hpps_memattr_cpu_s@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_memattr_cpu3_ns: hpps_memattr_cpu_ns@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_cpu3: hpps_cpu@3 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #3";

                reg = <3>;
                arm,mp-affinity = <3>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 3
                         /* NCPUHALT */ &apu 7
                         /* VINITHI  */ &apu 11>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu3_s>;
                memattr_ns = <&hpps_memattr_cpu3_ns>;
            };

            hpps_memattr_cpu4_s: hpps_memattr_cpu_s@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_memattr_cpu4_ns: hpps_memattr_cpu_ns@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_cpu4: hpps_cpu@4 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #4";

                reg = <0x4>;
                arm,mp-affinity = <0x100>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 4
                         /* NCPUHALT */ &apu1 4
                         /* VINITHI  */ &apu1 8>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu4_s>;
                memattr_ns = <&hpps_memattr_cpu4_ns>;
            };

            hpps_memattr_cpu5_s: hpps_memattr_cpu_s@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_memattr_cpu5_ns: hpps_memattr_cpu_ns@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_cpu5: hpps_cpu@5 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #5";

                reg = <0x5>;
                arm,mp-affinity = <0x101>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 5
                         /* NCPUHALT */ &apu1 5
                         /* VINITHI  */ &apu1 9>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu5_s>;
                memattr_ns = <&hpps_memattr_cpu5_ns>;
            };
            hpps_memattr_cpu6_s: hpps_memattr_cpu_s@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_memattr_cpu6_ns: hpps_memattr_cpu_ns@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_cpu6: hpps_cpu@6 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #6";

                reg = <0x6>;
                arm,mp-affinity = <0x102>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 6
                         /* NCPUHALT */ &apu1 6
                         /* VINITHI  */ &apu1 10>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu6_s>;
                memattr_ns = <&hpps_memattr_cpu6_ns>;
            };
            hpps_memattr_cpu7_s: hpps_memattr_cpu_s@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_memattr_cpu7_ns: hpps_memattr_cpu_ns@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_cpu7: hpps_cpu@7 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #7";

                reg = <0x7>;
                arm,mp-affinity = <0x103>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = </* RESET    */ &crf 7
                         /* NCPUHALT */ &apu1 7
                         /* VINITHI  */ &apu1 11>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                memattr_s = <&hpps_memattr_cpu7_s>;
                memattr_ns = <&hpps_memattr_cpu7_ns>;
            };

            /* TODO: is this used for anything? */
            cpu-map {
                cluster0 {
                    core0 { cpu = <&hpps_cpu0>; };
                    core1 { cpu = <&hpps_cpu1>; };
                    core2 { cpu = <&hpps_cpu2>; };
                    core3 { cpu = <&hpps_cpu3>; };
                };
                cluster1 {
                    core0 { cpu = <&hpps_cpu4>; };
                    core1 { cpu = <&hpps_cpu5>; };
                    core2 { cpu = <&hpps_cpu6>; };
                    core3 { cpu = <&hpps_cpu7>; };
                };
            };
        };
    };

    trch: trch { /* view of address space from TRCH CPU */
        compatible = "simple-bus";
        ranges ;

        trch_nvic: interrupt-controller@0xe000e000  {
            compatible = "arm,armv7m_nvic";
            interrupt-controller;
            #interrupt-cells = <3>;
            reg = <0xe000e000 0x420 /* prio = */ 0x0>;
            num-irq = <256>;
            cpu-id = <0>; /* TODO: could this be a ref to the cpu node? */
        };

#if 0 /* TODO: TRCH boot ROM not in current mem map
        trch_rom: trch_rom@TODO { /* accessed over I-/D-Code bus, so not over nic1 */
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <TODO TODO /* prio = */ 0x1>;
        };
#endif

        /* TODO: crf and crl will go away once TRCH reset controller is implemented */
        to_crf_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crf_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_crl_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crl_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_rpu_ctrl_bus { /* TODO: temporary hack, because both TRCH and RTPS (?) need this */
            compatible = "qemu:memory-region";
            alias = <&rpu_ctrl_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_apu_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&apu_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };

        to_nic1 {
            #priority-cells = <1>;
            compatible = "qemu:memory-region";
            alias = <&nic1>;
            reg = <0x0 /* size = */ 0xffffffff /* prio = -4 */ 0xfffffffc>;
        };
    };

    rtps: rtps { /* visible from both RTPS CPUs */
        compatible = "simple-bus";
        ranges ;

        rtps_gic: interrupt-controller@0x30e00000 {
                #address-cells = <0>;
                #size-cells = <0>;
                #interrupt-cells = <3>;
                #priority-cells = <0>;
                #gpio-cells = <0>;
                #redistributor-regions = <1>;

                compatible = "arm,arm-gicv3";
                revision = <3>;

                /* NOTE: if you change this address, also change arm,cfgperiphbase in cpu node */
                /* Addr Bits = 18 + log2(#cores) = 19 (see GIC-500 TRM Section 3.2) */
                reg = <0x30e00000  0x10000    /* prio = */ 0x1   /* GICD */
                       0x30e40000  0x40000    /* prio = */ 0x1>; /* GICR */
                interrupt-controller ;

                num-irq = <320>;
                cpu-start-id = <1>;
                num-cpu = <2>;

                interrupts-extended = /* signals output by the interrupt controller */
                        /* IRQ * #cpus; each wired to input signal 0=IRQ on each CPU */
                        <&rtps_cpu0 0>, <&rtps_cpu1 0>,
                        /* FIQ * #cpus, each wired to input signal 1=FIQ on each CPU */
                        <&rtps_cpu0 1>, <&rtps_cpu1 1>,
                        /* vIRQ * #cpus, each wired to input signal 2=vIRQ on each CPU */
                        <&rtps_cpu0 2>, <&rtps_cpu1 2>,
                        /* vFIQ * #cpus, each wired to input signal 3=vFIQ on each CPU */
                        <&rtps_cpu0 3>, <&rtps_cpu1 3>,
                        /* maintanance * #cpus: each wired to a set of inputs on this interrupt controller */
                            /* inputs into this interrupt controller:
                                       [0 .. num-irq-1]: SPI
                                       [num-irq * cpuidx .. num-irq * cpuidx + 32]: PPI for CPU# cpuidx ( * #cpus )
                               set of input irq# = { num-irq - 16 + idx + 32*cpuidx | foreach cpuidx set in bitmask }

                                   0(SPI)|1(PPI)    idx    bit[31:8]=bitmask of cpu set (i.e. of inputs in PPI range for each CPU) */
                        <&rtps_gic 0x1              0x9    0x0100>,
                        <&rtps_gic 0x1              0x9    0x0200>;
        };

        /* TODO: dummy node enabled in SPLIT mode only, revise this when implementing lock/split modes */
        ddr_memory_2_for_rpu: ddr_memory_2_for_rpu@0x60000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <0x60000 0x10000 /* prio = -1 */ 0xffffffff>;
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x0 0xffffffff /* prio = -2 */ 0xfffffffe>;
        };
    };

    rtps0: rtps@0 { /* view of address space from RTPS CPU0 */
        compatible = "simple-bus";
        ranges ;

        tcm_ram_r5_0_A: tcm_ram_r5_0_A@0x000000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0x100000 /* prio = */ 0x1>;
        };

        /* alias into RPU1 TCM for lockstep mode */
        atcm1_for_rpu0: atcm1_for_rpu0 {
            compatible = "qemu:memory-region";
            alias = <&tcm_ram_r5_1_A>;
            reg = <0x100000 0x100000 /* prio = */ 0x1>;
        };

        tcm_ram_r5_0_B: tcm_ram_r5_0_B@0x200000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x200000 0x100000 /* prio = */ 0x1>;
        };

        /* alias into RPU1 TCM for lockstep mode */
        btcm1_for_rpu0: btcm1_for_rpu0 {
            compatible = "qemu:memory-region";
            alias = <&tcm_ram_r5_1_B>;
            reg = <0x300000 0x100000 /* prio = */ 0x1>;
        };

        icache_rpu0: icache_rpu0@0x400000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x400000 0x8000 /* prio = */ 0x1>;
        };

        dcache_rpu0: dcache_rpu0@0x500000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x500000 0x8000 /* prio = */ 0x1>;
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    rtps1: rtps@1 {  /* view of address space from RTPS CPU0 */
        compatible = "simple-bus";
        ranges ;

        tcm_ram_r5_1_A: tcm_ram_r5_1_A@0x00000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0x10000 /* prio= */ 0x1>;
        };

        tcm_ram_r5_1_B: tcm_ram_r5_1_B@0x20000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x20000 0x10000 /* prio= */ 0x1>;
        };

        icache_rpu1: icache_rpu1@0x30000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x30000 0x8000 /* prio= */ 0x1>;
        };

        dcache_rpu1: dcache_rpu1@0x40000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x40000 0x8000 /* prio= */ 0x1>;
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    crf_bus: crf_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: to be replaced with Boeing design for reset controller */
        crf: crf@0xfd1a0000 {
            compatible = "xlnx,zynqmp_crf";
            reg = <0xfd1a0000 0x110 /* prio = */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
        };
    };

    crl_bus: crl_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: to be replaced with Boeing design for reset controller */
        crl: crl@0xff5e0000 {
            gpio-controller;
            #gpio-cells = <1>;
            compatible = "xlnx,zynqmp-crl";
            reg = <0xff5e0000 0x1000 /* prio = */ 0x0>;
            num-gpios = <16>; // is it controller(3) or client(1)?
            // pmu_global_client_gpios[] in xilinx_zynqmp_pmu_global.c
            //        : out: "error_2_out"
            // crl: controller_gpios : 0[RST_R5(0)], 1(RST_R5(1)], 2(SRST_B)
            // Then: if "error_2_out", RST_R5(0)?
            gpios = <&pmu_global 26>;
        };
    };

    rpu_ctrl_bus_descend1 { /* levels enforce dependency (on RTPS CPU nodes) */
        compatible = "simple-bus";
        ranges ;

        rpu_ctrl_bus_descend2 {
            compatible = "simple-bus";
            ranges ;

            rpu_ctrl_bus: rpu_ctrl_bus {
                compatible = "simple-bus";
                ranges ;

                /* TODO: to be replaced with Boeing design for reset controller */
                rpu_ctrl: rpu_control@0xff9a0000 {
                    gpio-controller;
                    #gpio-cells = <1>;
                    compatible = "xlnx,rpu-control";
                    reg = <0xff9a0000 0x400 /* prio = */ 0>;
                    atcm1-for-rpu0 = <&atcm1_for_rpu0>;
                    btcm1-for-rpu0 = <&btcm1_for_rpu0>;
                    icache-for-rpu1 = <&icache_rpu1>;
                    dcache-for-rpu1 = <&dcache_rpu1>;
                    ddr-mem-for-rpu = <&ddr_memory_2_for_rpu>;
                    gic-for-rpu = <&rtps_gic>;
                };
            };
        };
    };

    apu_bus: apu_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: Xilinx-specific? Needed by ATF/Linux */
        apu: apu@0xfd5c0000 {
            compatible = "xlnx,apu";
            #gpio-cells = <1>;
            reg = <0xfd5c0000 0x1000 /* prio= */ 0x0>;
            cpu0 = <&hpps_cpu0>;
            cpu1 = <&hpps_cpu1>;
            cpu2 = <&hpps_cpu2>;
            cpu3 = <&hpps_cpu3>;

            /* APU GPIO outputs:
                  wfi_out   *4 (NOT connected)
                  PWRDWNREQ *4 (connected to NCPUHALT input of HPPS CPUs)
                  VINITHI   *4 (connected to VINITHI input of HPPS CPUs)
             */
        };

        /* TODO: Xilinx-specific? Needed by ATF/Linux */
        apu1: apu1@0xfd5c1000 {
            compatible = "xlnx,apu";
            #gpio-cells = <1>;
            reg = <0xfd5c1000 0x1000 /* prio= */ 0x0>;
            cpu0 = <&hpps_cpu4>;
            cpu1 = <&hpps_cpu5>;
            cpu2 = <&hpps_cpu6>;
            cpu3 = <&hpps_cpu7>;
        };
    };

    hpps: hpps { /* view of address space from HPPS CPUs */
        #address-cells = <2>;
        #size-cells = <2>;
        compatible = "simple-bus";
        ranges ;

        hpps_gic: interrupt-controller@0xf9000000 {
                #address-cells = <0>;
                #size-cells = <0>;
                #priority-cells = <0>;
                #interrupt-cells = <3>;
                #gpio-cells = <0>;
                #redistributor-regions = <1>;

                compatible = "arm,arm-gicv3";
                revision = <3>;

                /* Addr Bits = 18 + log2(#cores) = 21 (see GIC-500 TRM Section 3.2) */
                reg = <0x0 0xf9000000  0x0 0x10000  /* prio = */ 0x0   /* GICD */
                       0x0 0xf9100000  0x0 0x100000 /* prio = */ 0x0>; /* GICR */
                interrupt-controller ;
                num-irq = <320>;
                interrupts-extended = /* signals output by the interrupt controller */
                        /* IRQ * #cpus; each wired to input signal 0=IRQ on each CPU */
                        <&hpps_cpu0 0>, <&hpps_cpu1 0>, <&hpps_cpu2 0>, <&hpps_cpu3 0>,
                        <&hpps_cpu4 0>, <&hpps_cpu5 0>, <&hpps_cpu6 0>, <&hpps_cpu7 0>,
                        /* FIQ * #cpus, each wired to input signal 1=FIQ on each CPU */
                        <&hpps_cpu0 1>, <&hpps_cpu1 1>, <&hpps_cpu2 1>, <&hpps_cpu3 1>,
                        <&hpps_cpu4 1>, <&hpps_cpu5 1>, <&hpps_cpu6 1>, <&hpps_cpu7 1>,
                        /* vIRQ * #cpus, each wired to input signal 2=vIRQ on each CPU */
                        <&hpps_cpu0 2>, <&hpps_cpu1 2>, <&hpps_cpu2 2>, <&hpps_cpu3 2>,
                        <&hpps_cpu4 2>, <&hpps_cpu5 2>, <&hpps_cpu6 2>, <&hpps_cpu7 2>,
                        /* vFIQ * #cpus, each wired to input signal 3=vFIQ on each CPU */
                        <&hpps_cpu0 3>, <&hpps_cpu1 3>, <&hpps_cpu2 3>, <&hpps_cpu3 3>,
                        <&hpps_cpu4 3>, <&hpps_cpu5 3>, <&hpps_cpu6 3>, <&hpps_cpu7 3>,
                        /* maintanance * #cpus: each wired to a set of inputs on this interrupt controller */
                            /* inputs into this interrupt controller:
                                       [0 .. num-irq-1]: SPI
                                       [num-irq * cpuidx .. num-irq * cpuidx + 32]: PPI for CPU# cpuidx ( * #cpus )
                               set of input irq# = { num-irq - 16 + idx + 32*cpuidx | foreach cpuidx set in bitmask }

                                   0(SPI)|1(PPI)    idx    bit[31:8]=bitmask of cpu set (i.e. of inputs in PPI range for each CPU) */
                        <&hpps_gic 0x1              0x9    0x0100>,
                        <&hpps_gic 0x1              0x9    0x0200>,
                        <&hpps_gic 0x1              0x9    0x0400>,
                        <&hpps_gic 0x1              0x9    0x0800>,
                        <&hpps_gic 0x1              0x9    0x1000>,
                        <&hpps_gic 0x1              0x9    0x2000>,
                        <&hpps_gic 0x1              0x9    0x4000>,
                        <&hpps_gic 0x1              0x9    0x8000>;

                cpu-start-id = <3>;
                num-cpu = <8>;
        };

        /* timer interrupt
            Secure Physical Timer event (ID 29 <= 16 + 13)
            Non-secure Physical Timer event (ID 30 <= 16 + 14)
            Virtual Timer event (ID 27 <= 16 + 11)
            Hypervisor Timer event (ID 26 <= 16 + 10) */
        timer {
            compatible = "arm,armv8-timer";
            interrupt-parent = <&hpps_gic>;
            interrupts = <1 13 0xff01>,
                         <1 14 0xff01>,
                         <1 11 0xff01>,
                         <1 10 0xff01>;
            clock-frequency = <100000000>;
        };

        cxtsgen@0xff250000 { /* TODO: present in Chiplet? ATF wants this. */
                compatible = "arm.generic-timer";
                reg = <0x0 0xff260000 0x0 0x1000 /* prio = */0x1>;
        };
        csu_core@0xffca0000 { /* TODO: present in Chiplet? Probably, not. ATF wants this. */
            compatible = "xlnx,zynqmp-csu-core";
            reg = <0x0 0xffca0000 0x0 0x100 /* prio = */ 0x1>;
        };

        /* TODO: both of these IPI nodes will go away once PSCI-via-TRCH is implemented */
        ipibuf_ram: ipibuf@ff990000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <0x0 0xff990000 0x0 0x1000 /* prio = */ 0x1>;
        };
        apu_ipi: apu_ipi@0xff300000 {
            compatible = "xlnx,zynqmp_ipi";
            gpio-controller;
            reg = <0x0 0xff300000 0x0 0x1000 /* prio = */ 0x1>;
            #gpio-cells = <2>;
            interrupts = <0>;
            interrupt-map =    <0 0 0 &hpps_gic  0 APU_IPI0_IRQ_0 4>;
            interrupt-map-mask = <0 0 0 0>;
            num-gpios = <64>;
            interrupt-gpios = <&apu_ipi 0 0>;
            gpios = <&apu_ipi 32 0>;
        };

        /* TODO: this will go away: no OCM on Chiplet */
        hpps_rom: hpps_rom@0x00000000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0x00000000 0x0 0x40000 /* prio = */ 0x1>;
        };

        /* TODO: this will go away: no OCM on Chiplet */
        hpps_sram: hpps_sram@0xfffc0000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0xfffc0000 0x0 0x40000 /* prio = */ 0x1>;
        };

        /* TODO: crf and crl will go away once TRCH reset controller is implemented */
        to_crf_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crf_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_crl_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crl_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_apu_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&apu_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };


        pmu_global: pmu_global@0xffd80000 {
            compatible = "xlnx,pmu_global";
            reg = <0x0 0xffd80000 0x0 0x40000 /* prio= */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
            num-gpios = <30>; /* pmu_global_client_gpios(30), pmu_global_controller_gpios(3 or 4) in xilinx_zynqmp_pmu_global.c */
            ignore-pwr-req = <1>;
        };

        to_ccn {
            compatible = "qemu:memory-region";
            alias = <&ccn>;
            reg = <0x0 0x0 /* size = */ 0xFFFFFFFF 0xFFFFFFFF /* prio = -1 */ 0xfffffffe>;
        };
    };

    nic1: nic1 {
        compatible = "simple-bus";
        ranges ;

        trch_sram: trch_sram@0x00000000 { /* TODO: could this also be accessed over I-/D-Code bus?
                                             If so, then we should move the definition one level
                                             above and add aliases to both here nic1{} and trch{}  */
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x00000000 0x100000 /* prio = */ 0x1>;
        };

        trch_dma_memattr: trch_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <1>;
            master-id = <MASTER_ID_TRCH_DMA>;
        };

        trch_dma: dma-controller@0x21000000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0x21000000 0x1000 /* prio= */ 0x0>;
            interrupts = <TRCH_DMA_ABORT_IRQ
                          TRCH_DMA_EV0_IRQ>; /* count must match num_events */
            #dma-cells = <1>;
            dma = <&nic1>;
            memattr = <&trch_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <0>; /* boot into secure mode */
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x38000000 0x1000 /* prio = */ 0x0>;
        };

        to_nic5 {
            compatible = "qemu:memory-region";
            alias = <&nic5>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    nic2: nic2 {
        compatible = "simple-bus";
        ranges ;

        /* TODO: RTPS SPI */

        to_nic3 {
            compatible = "qemu:memory-region";
            alias = <&nic3>;
            reg = <0x0 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
            
    };

    rtps_smmu_tbu0: rtps_smmu_tbu@0 { compatible = "simple-bus"; ranges ; };
    rtps_smmu_tbu1: rtps_smmu_tbu@1 { compatible = "simple-bus"; ranges ; };

    nic3: nic3 {
        compatible = "simple-bus";
        ranges ;

        rtps_ddr_low: rtps_ddr_low@0x40000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x40000000 0x40000000 /* prio= */ 0x0>;
        };

        rtps_smmu: rtps_smmu@0x31000000 {
            compatible = "arm,mmu-500";
            reg-extended = <&nic3 0x31000000    0x20000    /* prio= */ 0x0
                            &rtps_smmu_tbu0 0x0 0xffffffff /* prio= */ 0x0
                            &rtps_smmu_tbu1 0x0 0xffffffff /* prio= */ 0x0>;

            interrupts = <186 /* global irq */
                          /* context irqs */
                          187 188 189 190 191 192 193 194
                          195 196 197 198 199 200 201 202>;

            /* dma:  points to the MR used for PTWs.  */
            dma = <&nic3>;
            /* mr-x: points to the per TBU down-stream MR.  */
            mr-0 = <&nic3>;
            mr-1 = <&nic3>;
        };

        rtps_dma_memattr: rtps_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <1>;
            master-id = <MASTER_ID_RTPS_DMA>;
        };

        /* TODO: non-secure APB iface is at 0x30a09000: another node? */
        rtps_dma: dma-controller@0x30a08000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0x30a08000 0x1000 /* prio= */ 0x0>;
            interrupts = <RTPS_DMA_ABORT_IRQ
                          RTPS_DMA_EV0_IRQ>;
            #dma-cells = <1>;
            dma = <&rtps_smmu_tbu0>;
            memattr = <&rtps_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <0>; /* boot into secure mode */
        };

        /* TODO: PCIe (dma = <&rtps_smmu_tbu1>) */

        to_nic5 {
            compatible = "qemu:memory-region";
            alias = <&nic5>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    nic4: nic4 { /* lsio */
        compatible = "simple-bus";
        ranges ;

        lsio_mailbox: mailbox@0x3000a000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts  = <  72  73  74  75  76  77  78  79
                             80  81  82  83  84  85  86  87>;
            reg = <0x3000a000 0x1000 /* prio = */ 0x0>;
        };

        lsio_uart_0: serial@0x30000000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0x30000000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <LSIO_UART0_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

        lsio_uart_1: serial@0x30001000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0x30001000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <LSIO_UART1_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

            /* TODO: SMC353 */
            /* TODO: GPIO */
            /* TODO: I2C */
            /* TODO: SPI */
    };

    nic5: nic5 {
        compatible = "simple-bus";
        ranges ;

        /* {RTPS,TRCH} -> HPPS MMU */
        rt_smmu: smmu0@0x31100000 {
            compatible = "arm,mmu-500";
            reg-extended = <&nic5 0x31100000 0x20000     /* prio = */ 0x0
                            &nic5 0          0xffffffff  /* prio = */ 0xfffffffe>; /* master connected to slave interface of MMU */

            interrupts = <169 /* global irq */
                          /* context irqs (16 contexts hardcoded in model) */
                          170 171 172 173 174 175 176 177
                          178 179 180 181 182 183 184 185>;

            /* dma:  points to the MR used for PTWs.  */
            /* mr-x: points to the per TBU down-stream MR.  */
            dma = <&ccn>;
            mr-0 = <&ccn>;
        };

        to_nic4 { /* lsio */
                compatible = "qemu:memory-region";
                alias = <&nic4>;
                /* reg = <0x30000000 0x3000b0000 * prio = * 0x0>; */
                reg = <0x0 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
    };

    mdio0: mdio {
        #address-cells = <1>;
        #size-cells = <0>;
        compatible="mdio";
        phy0: phy@7 {
            compatible = "88e1118r";
            device_type = "ethernet-phy";
            reg = <7>;
        };
    };

    hpps_smmu_tbu0: hpps_smmu_tbu@0 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu1: hpps_smmu_tbu@1 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu2: hpps_smmu_tbu@2 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu3: hpps_smmu_tbu@3 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu4: hpps_smmu_tbu@4 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu5: hpps_smmu_tbu@5 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu6: hpps_smmu_tbu@6 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu7: hpps_smmu_tbu@7 { compatible = "simple-bus"; ranges ; };

    nic6: nic6 {
        compatible = "simple-bus";
        ranges ;

        hpps_trch_mailbox: mailbox@0xfff50000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <136 137 138 139 140 141 142 143
                          144 145 146 147 148 149 150 151>;
            reg = <0xfff50000 0x1000 /* prio = */ 0x0>;
        };

        hpps_rtps_mailbox: mailbox@0xfff60000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <203 204 205 206 207 208 209 210
                          211 212 213 214 215 216 217 218>;
            reg = <0xfff60000 0x1000 /* prio = */ 0x0>;
        };

        hpps_uart_0: serial@0xf92c0000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0xf92c0000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <HPPS_UART0_IRQ_0>;
            port-number = <1>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

        smc353: smc353@0xf92d0000 {
            #address-cells = <2>;
            #size-cells = <2>;
            arm,addr25 = <0x0>;
            clock-names = "memclk", "aclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "arm,pl35x";
            reg = <0xf92d0000 0x1000 /* prio = */ 0x0>;
            interrupts = <NAND_IRQ_0>;
            x = <3>;
            ranges ;
			nand {
				#address-cells = <1>;
				#size-cells = <1>;

				partition@0 {
					label = "all";
					reg   = <0x00000000 0x80000000>;
				};
			};
			sram {
				#address-cells = <1>;
				#size-cells = <1>;
					reg   = <0x80000000 0x80000000>;
			};
#ifdef ORG
            nand0: nand0@0x600000000 {
                arm,nand-cycle-t0 = <0x4>;
                arm,nand-cycle-t1 = <0x4>;
                arm,nand-cycle-t2 = <0x1>;
                arm,nand-cycle-t3 = <0x2>;
                arm,nand-cycle-t4 = <0x2>;
                arm,nand-cycle-t5 = <0x2>;
                arm,nand-cycle-t6 = <0x4>;
                chip_id = <0xaa>;
                manufacturer_id = <0x2c>;
                drive = "";
                label = "nand0";
                status = "disabled";
                compatible = "nand";
                reg = <0x6 0x00000000 0x0 0x80000000 /* prio = 0 */ 0x0>;
                #address-cells = <0x2>;
                #size-cells = <0x2>;
            };
#endif
#ifdef SRAM
            sram0: sram0@0x680000000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <0x6 0x80000000 0x0 0x80000000 /* prio = */ 0x0>;
                #address-cells = <0x2>;
                #size-cells = <0x2>;
            }; 
#endif 
        };

        hpps_smmu: smmu@0xf9300000 {
                compatible = "arm,mmu-500";
                reg-extended = <&nic6 0xf9300000  0x20000     /* prio = */ 0x0
                                &hpps_smmu_tbu0 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu1 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu2 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu3 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu4 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu5 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu6 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu7 0 0xffffffff  /* prio = */ 0x0>;

                interrupts = <152 /* global irq */
                              /* context irqs (16 ctx hardcoded into model) */
                              153 154 155 156 157 158 159 160
                              161 162 163 164 165 166 167 168>;

                /* dma:  points to the MR used for PTWs.  */
                dma = <&nic7>;

                /* mr-x: points to the per TBU down-stream MR.  */
                mr-0 = <&nic7>; /* DMA */
                mr-1 = <&nic7>; /* PCIe */
                mr-2 = <&nic7>; /* Ethernet */
                mr-3 = <&nic7>; /* TTE */
                mr-4 = <&nic7>; /* SRIO DMA 0 */
                mr-5 = <&nic7>; /* SRIO DMA 1 */
                mr-6 = <&nic7>; /* SRIO EP 0 */
                mr-7 = <&nic7>; /* SRIO EP 1 */
        };

        hpps_dma_memattr: hpps_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_HPPS_DMA>;
        };

        /* TODO: secure at 0xf92f0000: another node? */
        hpps_dma: dma-controller@0xf92e0000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xf92e0000 0x1000 /* prio = */ 0x0>;
            interrupts = <HPPS_DMA_ABORT_IRQ
                          HPPS_DMA_EV0_IRQ>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu0>;
            memattr = <&hpps_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        srio0_dma_memattr: srio0_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_SRIO0_DMA>;
        };

        /* TODO: secure at 0xe5320000: another node? */
        srio0_dma: dma-controller@0xe5310000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xe5310000 0x1000 /* prio = */ 0x0>;
            interrupts = <SRIO0_DMA_ABORT_IRQ
                          SRIO0_DMA_EV0_IRQ>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu4>;
            memattr = <&srio0_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        srio1_dma_memattr: srio1_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_SRIO1_DMA>;
        };

        /* TODO: secure at 0xe5340000: another node? */
        srio1_dma: dma-controller@0xe5330000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xe5330000 0x1000 /* prio = */ 0x0>;
            interrupts = <SRIO1_DMA_ABORT_IRQ
                          SRIO1_DMA_EV0_IRQ>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu5>;
            memattr = <&srio1_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        xgmac_memattr: xgmac_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_XGMAC>;
        };
        xgmac: ethernet@0xe5300000 {
            #stream-id-cells = <0x1>;
            #address-cells = <1>;
            #size-cells = <0>;
            #priority-cells = <0>;
            reg = <0xe5300000 0x1000 /* prio = */ 0x0>;
            clock-names = "hclk", "pclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "xlnx,ps7-ethernet-1.00.a", "cdns,gem";  /* TODO: change to Synopsys DWC_ether */
            interrupts = <XGMAC_IRQ_0 XGMAC_IRQ_1_WAKE>;
            dma = <&hpps_smmu_tbu2>;
            memattr = <&xgmac_memattr>;
            local-mac-address = [00 0a 35 00 02 90];
            num-priority-queues = <1>;
            revision = <0x40070106>;
            mdio = <&mdio0>;
        };

        /* TODO: PCIe */
        /* TODO: Spacewire */
        /* TODO: TTE */
    };

    nic7: nic7 { /* HSIO goes through HPPS SMMU then through this NIC */
        #address-cells = <2>;
        #size-cells = <2>;

        compatible = "simple-bus";
        ranges ;

        to_ccn {
            compatible = "qemu:memory-region";
            alias = <&ccn>;
            reg = <0x0 0x0 /* size = */ 0xFFFFFFFF 0xFFFFFFFF /* prio = -1 */ 0xfffffffe>;
        };
    };

    ccn: ccn {
        #address-cells = <2>;
	#size-cells = <2>;    

        compatible = "simple-bus";
        ranges ;

        hpps_ddr_low: hpps_ddr_low@0x80000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x0 0x80000000 0x0 0x40000000 /* prio = */ 0x0>;
        };

        hpps_ddr_high0: hpps_ddr_high0@0x100000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x1 0x00000000 0x0 0x80000000 /* prio = */ 0x0>;
        };

        to_nic6 {
            compatible = "qemu:memory-region";
            alias = <&nic6>;
            /* reg = <0xF9220000 0x000C0000 * prio = -1 * 0xffffffff>; */ /* TODO: why does this not work? */
            reg = <0x0 0x0 0x6 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
    };

    uart_clk: uart_clk {
        #clock-cells = <0>;
        clock-frequency = <25000000>;
        compatible = "fixed-clock";
    };

    misc_clk: misc_clk {
        #clock-cells = <0>;
        clock-frequency = <50000000>;
        compatible = "fixed-clock";
    };

    /* arm_generic_fdt insists on having a memory node at root: we won't use this */
    /* TODO: get rid of this */
    dummy_memory: memory {
        compatible = "qemu:memory-region";
        qemu,ram = <1>;
        reg = <0x0 0xffffffff /* prio = */ 0x0>;
    };
};
