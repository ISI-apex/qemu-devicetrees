#define MASTER_ID_TRCH_CPU  0x2d

#define MASTER_ID_RTPS_CPU0 0x2e
#define MASTER_ID_RTPS_CPU1 0x2f

#define MASTER_ID_HPPS_CPU0 0x80
#define MASTER_ID_HPPS_CPU1 0x8d
#define MASTER_ID_HPPS_CPU2 0x8e
#define MASTER_ID_HPPS_CPU3 0x8f
#define MASTER_ID_HPPS_CPU4 0x90
#define MASTER_ID_HPPS_CPU5 0x9d
#define MASTER_ID_HPPS_CPU6 0x9e
#define MASTER_ID_HPPS_CPU7 0x9f

#define MASTER_ID_XGMAC     0x874
#define MASTER_ID_TRCH_DMA  0x875
#define MASTER_ID_RTPS_DMA  0x876
#define MASTER_ID_HPPS_DMA  0x877
#define MASTER_ID_SRIO0_DMA 0x878
#define MASTER_ID_SRIO1_DMA 0x879

/* TODO: renumber IRQs */

#define HPPS_SMC_IRQ			 14
#define TRCH_SMC_IRQ			 15

#define WDT_TRCH_ST1_IRQ                 17
#define WDT_TRCH_ST2_IRQ                 18

#define WDT_RTPS0_ST2_IRQ                19
#define WDT_RTPS1_ST2_IRQ                20

#define LSIO_UART0_IRQ_0		 21
#define LSIO_UART1_IRQ_0		 22
#define HPPS_UART0_IRQ_0		 23

#define WDT_HPPS0_ST2_IRQ                24
#define WDT_HPPS1_ST2_IRQ                25
#define WDT_HPPS2_ST2_IRQ                26
#define WDT_HPPS3_ST2_IRQ                27
#define WDT_HPPS4_ST2_IRQ                28
#define WDT_HPPS5_ST2_IRQ                29
#define WDT_HPPS6_ST2_IRQ                30
#define WDT_HPPS7_ST2_IRQ                31

#define XGMAC_IRQ_0			 57
#define XGMAC_IRQ_1_WAKE		 58

#define TRCH_DMA_ABORT_IRQ		59
#define TRCH_DMA_EV0_IRQ		60
#define RTPS_DMA_ABORT_IRQ		61
#define RTPS_DMA_EV0_IRQ		62
#define HPPS_DMA_ABORT_IRQ		63
#define HPPS_DMA_EV0_IRQ		64
#define SRIO0_DMA_ABORT_IRQ		65
#define SRIO0_DMA_EV0_IRQ		66
#define SRIO1_DMA_ABORT_IRQ		67
#define SRIO1_DMA_EV0_IRQ		68

#define RTPS_SMMU_IRQ			69
#define HPPS_SMMU0_IRQ			70
#define HPPS_SMMU1_IRQ			71

/* #define TRCH_MAILBOX_IRQs  	        72-87 */
/* #define HPPS_TRCH_MAILBOX_IRQs  	136-151 */
/* #define HPPS_SMMU_GLOB_IRQ           152 */
/* #define HPPS_SMMU_CB_IRQ             153-168 */
/* #define RT_SMMU_GLOB_IRQ             169 */
/* #define RT_SMMU_CB_IRQ               170-185 */
/* #define RTPS_SMMU_GLOB_IRQ           186 */
/* #define RTPS_SMMU_CB_IRQ             187-202 */
/* #define HPPS_RTPS_MAILBOX_IRQs  	203-218 */

#define APU_IPI0_IRQ_0				35

/* See Table 2-2 in ARM GIC Spec for recommended assignment,
   and note that PPI ID = INTID - GIC_NR_SGIS = INTID-16 */
#define TIMER_PHYS_PPI_IRQ              14
#define TIMER_SEC_PPI_IRQ               13
#define TIMER_VIRT_PPI_IRQ              11
#define TIMER_HYP_PPI_IRQ               10

#define GIC_MAINT_PPI_IRQ                9
#define WDT_PPI_IRQ                      8

/* TODO: The secondary CPU entry point is normally set by PSCI
   code at time of reset request (also, the PSCI code uses the symbol instead
   of a raw address). However, the setting of rvbar CPU property is currently
   broken; so, for now, we define the entry point here. */
#define HPPS_RESET_ADDR_PRIMARY_CPU   0x80000000 /* ATF bl31_entrypoint */
#define HPPS_RESET_ADDR_SECONDARY_CPU 0x80000110 /* ATF bl31_warm_entrypoint */

#define GIC_SPI 0
#define GIC_PPI 1

#define GIC_EDGE_RISE 1
#define GIC_EDGE_FALL 2
#define GIC_EDGE_BOTH 3
#define GIC_LVL_HI    4
#define GIC_LVL_LO    8

/dts-v1/;

/ {
    #address-cells = <1>;
    #size-cells = <1>;
    #priority-cells = <1>;
    #interrupt-cells = <1>; /* within the scope of each interrupt-map */

    cpus {
        #size-cells = <0>;
        #priority-cells = <0>;

        trch_cpus {
            trch_memattr_cpu: trch_memattr_cpu@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_TRCH_CPU>;
            };

            trch_cpu: trch_cpu {
                #address-cells = <1>;

                compatible = "cortex-m4f-arm-cpu";
                device_type = "cpu";
                reg = <0>;

                gdb-id = "TRCH Cortex-M4";

                clock-frequency = <100000000>;
                d-cache-line-size = <0x20>;            
                d-cache-size = <0x1000>;            
                i-cache-line-size = <0x20>;        
                i-cache-size = <0x200>;

                arm,midr = <0x410fc240>;
                arm,ctr = <0x83338003>;
                arm,clidr = <0x09200003>;
                arm,id_pfr0 = <0x30>;
                arm,ccsidr1 = <0x24770011>;

                timebase-frequency = <100000000>;

                mr = <&trch>;
                memory = <&trch>;
                memattr_ns = <&trch_memattr_cpu>;
                /* TODO: memattr_s, mr-secure : ? */

                /* TODO: add a reset controller between RESET and LAST_TIMEOUT,
                         because LAST_TIMEOUT should reset all blocks within
                         TRCH IP, not only the M4 core. */
                gpios = /* input signals */
                        </* RESET    */ &trch_wdt 0 /* LAST_TIMEOUT */
                         /* NCPUHALT */ /* disconnected */
                         /* VINITHI  */ /* disconnected */>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";
            };
        };

        rtps_cpus {

#define RTPS_CPU_PROPS                                 \
                #interrupt-cells = <1>;                \
                compatible = "cortex-r52f-arm-cpu";    \
                device_type = "cpu";                   \
                d-cache-line-size = <0x20>;            \
                d-cache-size = <0x8000>;               \
                i-cache-line-size = <0x20>;            \
                i-cache-size = <0x8000>;               \
                arm,midr=<0x411fd130>;                 \
                arm,tcmtr=<0x00010003>;                \
                arm,ctr=<0x8144c004>;                  \
                arm,clidr=<0x09200003>;                \
                arm,ccsidr0 = <0xf01fe019>;            \
                arm,ccsidr1 = <0xf01fe019>;            \
                arm,id_pfr0 = <0x131>;                 \
                arm,reset_sctlr = <0x30c50838>;        \
                arm,rvbar = <0x60000000>;              \
                arm,vbar = <0x60000000>;               \
                arm,cfgperiphbase = <0x28000000>;      \
                arm,buildoptr= <0x00f00000>;           \
                arm,pinoptr= <0x00000000>;             \
                arm,atcmregionr = <0x00000014>;        \
                arm,btcmregionr = <0x00004014>;        \
                arm,ctcmregionr = <0x00008014>;        \
                start-powered-off = <1>;               \

            rtps_memattr_cpu0: rtps_memattr_cpu@0 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU0>;
            };
            rtps_cpu0: rtps_cpu@0 {
                RTPS_CPU_PROPS
                reg = <0>;
                gdb-id = "RTPS Cortex-R52 #0";
                arm,mp-affinity = <0x0>;

                mr = <&rtps0>;
                memory = <&rtps0>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu0>;

                gpios = /* input signals */
                        </* RST_R5[0] */    &crl 0
                         /* R5_0_HALT */    &rpu_ctrl 0
                         /* R5_0_VINITHI */ &rpu_ctrl 5 >;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx      [31:8]=cpus bitmask
                                                            [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&rtps_gic GIC_PPI TIMER_PHYS_PPI_IRQ 0x0108>, /* Physical Timer event            (ID 29 <= 16 + idx) */
                             <&rtps_gic GIC_PPI TIMER_VIRT_PPI_IRQ 0x0108>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&rtps_gic GIC_PPI TIMER_HYP_PPI_IRQ  0x0108>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";
            };

            rtps_memattr_cpu1: rtps_memattr_cpu@1 {
                    compatible = "qemu:memory-transaction-attr";
                    secure = <1>;
                    master-id = <MASTER_ID_RTPS_CPU1>;
            };
            rtps_cpu1: rtps_cpu@1 {
                RTPS_CPU_PROPS
                reg = <1>;
                gdb-id = "RTPS Cortex-R52 #1";
                arm,mp-affinity = <0x1>;

                mr = <&rtps1>;
                memory = <&rtps1>;

                /* TODO: memattr_s = ? */
                memattr_ns = <&rtps_memattr_cpu1>;

                gpios = /* input signals */
                        </* RST_R5[1] */    &crl 1
                         /* R5_1_HALT */    &rpu_ctrl 1
                         /* R5_1_VINITHI */ &rpu_ctrl 6 >;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx      [31:8]=cpus bitmask
                                                            [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&rtps_gic GIC_PPI TIMER_PHYS_PPI_IRQ 0x0208>, /* Physical Timer event            (ID 29 <= 16 + idx) */
                             <&rtps_gic GIC_PPI TIMER_VIRT_PPI_IRQ 0x0208>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&rtps_gic GIC_PPI TIMER_HYP_PPI_IRQ  0x0208>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";
            };
        };

        hpps_cpus {

#define HPPS_CPU_PROPS                                    \
                #interrupt-cells = <1>;                   \
                compatible = "cortex-a53-arm-cpu";        \
                device_type = "cpu";                      \
                d-cache-line-size = <0x20>;               \
                d-cache-size = <0x8000>;                  \
                i-cache-line-size = <0x20>;               \
                i-cache-size = <0x8000>;                  \
                arm,midr = <0x410fd032>;                  \
                arm,ctr = <0x83338003>;                   \
                arm,clidr = <0x09200003>;                 \
                arm,id_pfr0 = <0x1231>;                   \
                arm,ccsidr0 = <0x701fe019>;               \
                arm,ccsidr1 = <0x201fe019>;               \
                enable-method = "psci";                   \
                arm,reset-hivecs = <1>;                   \
                arm,reset-cbar = <0xfd3fe000>;            \
                start-powered-off = <1>;                  \
                mr = <&hpps>;                             \
                memory = <&hpps>;                         \
                memory_ns = <&hpps>;                      \


            hpps_memattr_cpu0_s: hpps_memattr_cpu_s@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu0_ns: hpps_memattr_cpu_ns@0 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_cpu0: hpps_cpu@0 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #0";

                reg = <0>;
                arm,mp-affinity = <0>;
                arm,rvbar = <HPPS_RESET_ADDR_PRIMARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 0
                         /* NCPUHALT */ &apu 4
                         /* VINITHI  */ &apu 8>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x0108>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x0108>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x0108>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x0108>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu0_s>;
                memattr_ns = <&hpps_memattr_cpu0_ns>;
            };

            hpps_memattr_cpu1_s: hpps_memattr_cpu_s@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU0>;
            };
            hpps_memattr_cpu1_ns: hpps_memattr_cpu_ns@1 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU1>;
            };
            hpps_cpu1: hpps_cpu@1 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #1";

                reg = <1>;
                arm,mp-affinity = <1>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 1
                         /* NCPUHALT */ &apu 5
                         /* VINITHI  */ &apu 9>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x0208>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x0208>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x0208>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x0208>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu1_s>;
                memattr_ns = <&hpps_memattr_cpu1_ns>;
            };

            hpps_memattr_cpu2_s: hpps_memattr_cpu_s@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_memattr_cpu2_ns: hpps_memattr_cpu_ns@2 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU2>;
            };
            hpps_cpu2: hpps_cpu@2 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #2";

                reg = <2>;
                arm,mp-affinity = <2>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 2
                         /* NCPUHALT */ &apu 6
                         /* VINITHI  */ &apu 10>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x0408>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x0408>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x0408>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x0408>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu2_s>;
                memattr_ns = <&hpps_memattr_cpu2_ns>;
            };

            hpps_memattr_cpu3_s: hpps_memattr_cpu_s@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_memattr_cpu3_ns: hpps_memattr_cpu_ns@3 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU3>;
            };
            hpps_cpu3: hpps_cpu@3 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #3";

                reg = <3>;
                arm,mp-affinity = <3>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 3
                         /* NCPUHALT */ &apu 7
                         /* VINITHI  */ &apu 11>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x0808>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x0808>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x0808>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x0808>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu3_s>;
                memattr_ns = <&hpps_memattr_cpu3_ns>;
            };

            hpps_memattr_cpu4_s: hpps_memattr_cpu_s@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_memattr_cpu4_ns: hpps_memattr_cpu_ns@4 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU4>;
            };
            hpps_cpu4: hpps_cpu@4 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #4";

                reg = <0x4>;
                arm,mp-affinity = <0x100>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 4
                         /* NCPUHALT */ &apu1 4
                         /* VINITHI  */ &apu1 8>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x1008>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x1008>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x1008>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x1008>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu4_s>;
                memattr_ns = <&hpps_memattr_cpu4_ns>;
            };

            hpps_memattr_cpu5_s: hpps_memattr_cpu_s@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_memattr_cpu5_ns: hpps_memattr_cpu_ns@5 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU5>;
            };
            hpps_cpu5: hpps_cpu@5 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #5";

                reg = <0x5>;
                arm,mp-affinity = <0x101>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 5
                         /* NCPUHALT */ &apu1 5
                         /* VINITHI  */ &apu1 9>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x2008>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x2008>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x2008>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x2008>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu5_s>;
                memattr_ns = <&hpps_memattr_cpu5_ns>;
            };
            hpps_memattr_cpu6_s: hpps_memattr_cpu_s@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_memattr_cpu6_ns: hpps_memattr_cpu_ns@6 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU6>;
            };
            hpps_cpu6: hpps_cpu@6 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #6";

                reg = <0x6>;
                arm,mp-affinity = <0x102>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 6
                         /* NCPUHALT */ &apu1 6
                         /* VINITHI  */ &apu1 10>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x4008>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x4008>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x4008>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x4008>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu6_s>;
                memattr_ns = <&hpps_memattr_cpu6_ns>;
            };
            hpps_memattr_cpu7_s: hpps_memattr_cpu_s@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <1>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_memattr_cpu7_ns: hpps_memattr_cpu_ns@7 {
                compatible = "qemu:memory-transaction-attr";
                secure = <0>;
                master-id = <MASTER_ID_HPPS_CPU7>;
            };
            hpps_cpu7: hpps_cpu@7 {
                HPPS_CPU_PROPS
                gdb-id = "HPPS Cortex-A53 #7";

                reg = <0x7>;
                arm,mp-affinity = <0x103>;
                arm,rvbar = <HPPS_RESET_ADDR_SECONDARY_CPU>;

                gpios = /* input signals */
                        </* RESET    */ &crf 7
                         /* NCPUHALT */ &apu1 7
                         /* VINITHI  */ &apu1 11>;
                gpio-names = "reset",
                             "ncpuhalt",
                             "vinithi";

                interrupts-extended = /* output signals */
                             /* ARMv8 Generic Timer output signals */
                             /* intc    type       idx  [31:8]=cpus bitmask [0:7]=level(8=low) (a PPI ided by (idx,bit in mask)) */
                             <&hpps_gic GIC_PPI    13 	0x8008>, /* Secure Physical Timer event     (ID 29 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    14 	0x8008>, /* Non-secure Physical Timer event (ID 30 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    11 	0x8008>, /* Virtual Timer event             (ID 27 <= 16 + idx) */
                             <&hpps_gic GIC_PPI    10 	0x8008>; /* Hypervisor Timer event          (ID 26 <= 16 + idx) */
                             /* TODO: wfi, gicv3-maintenance-interrupt, pmu-interrupt */
                interrupt-names =
                             "timer_sec",
                             "timer_phys",
                             "timer_virt",
                             "timer_hyp";

                memattr_s = <&hpps_memattr_cpu7_s>;
                memattr_ns = <&hpps_memattr_cpu7_ns>;
            };

            /* TODO: is this used for anything? */
            cpu-map {
                cluster0 {
                    core0 { cpu = <&hpps_cpu0>; };
                    core1 { cpu = <&hpps_cpu1>; };
                    core2 { cpu = <&hpps_cpu2>; };
                    core3 { cpu = <&hpps_cpu3>; };
                };
                cluster1 {
                    core0 { cpu = <&hpps_cpu4>; };
                    core1 { cpu = <&hpps_cpu5>; };
                    core2 { cpu = <&hpps_cpu6>; };
                    core3 { cpu = <&hpps_cpu7>; };
                };
            };
        };
    };

    trch: trch { /* view of address space from TRCH CPU */
        compatible = "simple-bus";
        ranges ;

        trch_nvic: interrupt-controller@0xe000e000  {
            compatible = "arm,armv7m_nvic";
            interrupt-controller;
            #interrupt-cells = <1>;
            reg = <0xe000e000 0x420 /* prio = */ 0x0>;
            num-irq = <256>;
            cpu-id = <0>; /* TODO: could this be a ref to the cpu node? */
        };

#if 0 /* TODO: TRCH boot ROM not in current mem map
        trch_rom: trch_rom@TODO { /* accessed over I-/D-Code bus, so not over nic1 */
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <TODO TODO /* prio = */ 0x1>;
        };
#endif

        /* TODO: crf and crl will go away once TRCH reset controller is implemented */
        to_crf_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crf_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_crl_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crl_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_rpu_ctrl_bus { /* TODO: temporary hack, because both TRCH and RTPS (?) need this */
            compatible = "qemu:memory-region";
            alias = <&rpu_ctrl_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_apu_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&apu_bus>;
            reg = <0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };

        to_nic1 {
            #priority-cells = <1>;
            compatible = "qemu:memory-region";
            alias = <&nic1>;
            reg = <0x0 /* size = */ 0xffffffff /* prio = -4 */ 0xfffffffc>;
        };
    };

    rtps: rtps { /* visible from both RTPS CPUs */
        compatible = "simple-bus";
        ranges ;

        rtps_gic: interrupt-controller@0x30e00000 {
                #address-cells = <0>;
                #size-cells = <0>;
                #interrupt-cells = <3>;
                #priority-cells = <0>;
                #gpio-cells = <0>;
                #redistributor-regions = <1>;

                compatible = "arm,arm-gicv3";
                revision = <3>;

                /* NOTE: if you change this address, also change arm,cfgperiphbase in cpu node */
                /* Addr Bits = 18 + log2(#cores) = 19 (see GIC-500 TRM Section 3.2) */
                reg = <0x30e00000  0x10000    /* prio = */ 0x1   /* GICD */
                       0x30e40000  0x40000    /* prio = */ 0x1>; /* GICR */
                interrupt-controller ;

                num-irq = <320>;
                cpu-start-id = <1>;
                num-cpu = <2>;

                interrupts-extended = /* signals output by the interrupt controller */
                        /* IRQ * #cpus; each wired to input signal 0=IRQ on each CPU */
                        <&rtps_cpu0 0>, <&rtps_cpu1 0>,
                        /* FIQ * #cpus, each wired to input signal 1=FIQ on each CPU */
                        <&rtps_cpu0 1>, <&rtps_cpu1 1>,
                        /* vIRQ * #cpus, each wired to input signal 2=vIRQ on each CPU */
                        <&rtps_cpu0 2>, <&rtps_cpu1 2>,
                        /* vFIQ * #cpus, each wired to input signal 3=vFIQ on each CPU */
                        <&rtps_cpu0 3>, <&rtps_cpu1 3>,
                        /* maintanance * #cpus: each wired to a set of inputs on this interrupt controller */
                            /* inputs into this interrupt controller:
                                       [0 .. num-irq-1]: SPI
                                       [num-irq * cpuidx .. num-irq * cpuidx + 32]: PPI for CPU# cpuidx ( * #cpus )
                               set of input irq# = { num-irq - 16 + idx + 32*cpuidx | foreach cpuidx set in bitmask }

                         intc      type    idx                  bit[31:8]=bitmask of cpu set, bit[7:0]=cfg (8=level) */
                        <&rtps_gic GIC_PPI GIC_MAINT_PPI_IRQ    0x0108>,
                        <&rtps_gic GIC_PPI GIC_MAINT_PPI_IRQ    0x0208>;
        };

        /* TODO: dummy node enabled in SPLIT mode only, revise this when implementing lock/split modes */
        ddr_memory_2_for_rpu: ddr_memory_2_for_rpu@0x60000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <0x60000 0x10000 /* prio = -1 */ 0xffffffff>;
        };

        /* This is a wormhole in hardware, there's no actual access to nic1 */
        to_rtps_wdt {
            compatible = "qemu:memory-region";
            alias = <&rtps_wdts>;
            reg = <0x30a0a000 0x2000 /* prio = 0 */ 0x0>;
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x0 0xffffffff /* prio = -2 */ 0xfffffffe>;
        };
    };

    rtps0: rtps@0 { /* view of address space from RTPS CPU0 */
        compatible = "simple-bus";
        ranges ;

        tcm_ram_r5_0_A: tcm_ram_r5_0_A@0x000000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0x100000 /* prio = */ 0x1>;
        };

        /* alias into RPU1 TCM for lockstep mode */
        atcm1_for_rpu0: atcm1_for_rpu0 {
            compatible = "qemu:memory-region";
            alias = <&tcm_ram_r5_1_A>;
            reg = <0x100000 0x100000 /* prio = */ 0x1>;
        };

        tcm_ram_r5_0_B: tcm_ram_r5_0_B@0x200000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x200000 0x100000 /* prio = */ 0x1>;
        };

        /* alias into RPU1 TCM for lockstep mode */
        btcm1_for_rpu0: btcm1_for_rpu0 {
            compatible = "qemu:memory-region";
            alias = <&tcm_ram_r5_1_B>;
            reg = <0x300000 0x100000 /* prio = */ 0x1>;
        };

        icache_rpu0: icache_rpu0@0x400000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x400000 0x8000 /* prio = */ 0x1>;
        };

        dcache_rpu0: dcache_rpu0@0x500000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x500000 0x8000 /* prio = */ 0x1>;
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    rtps1: rtps@1 {  /* view of address space from RTPS CPU0 */
        compatible = "simple-bus";
        ranges ;

        tcm_ram_r5_1_A: tcm_ram_r5_1_A@0x00000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x0 0x10000 /* prio= */ 0x1>;
        };

        tcm_ram_r5_1_B: tcm_ram_r5_1_B@0x20000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x20000 0x10000 /* prio= */ 0x1>;
        };

        icache_rpu1: icache_rpu1@0x30000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x30000 0x8000 /* prio= */ 0x1>;
        };

        dcache_rpu1: dcache_rpu1@0x40000 {
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x40000 0x8000 /* prio= */ 0x1>;
        };

        to_rtps {
            compatible = "qemu:memory-region";
            alias = <&rtps>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    crf_bus: crf_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: to be replaced with Boeing design for reset controller */
        crf: crf@0xfd1a0000 {
            compatible = "xlnx,zynqmp_crf";
            reg = <0xfd1a0000 0x110 /* prio = */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
        };
    };

    crl_bus: crl_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: to be replaced with Boeing design for reset controller */
        crl: crl@0xff5e0000 {
            gpio-controller;
            #gpio-cells = <1>;
            compatible = "xlnx,zynqmp-crl";
            reg = <0xff5e0000 0x1000 /* prio = */ 0x0>;
            num-gpios = <16>; // is it controller(3) or client(1)?
            // pmu_global_client_gpios[] in xilinx_zynqmp_pmu_global.c
            //        : out: "error_2_out"
            // crl: controller_gpios : 0[RST_R5(0)], 1(RST_R5(1)], 2(SRST_B)
            // Then: if "error_2_out", RST_R5(0)?
            gpios = <&pmu_global 26>;
        };
    };

    rpu_ctrl_bus_descend1 { /* levels enforce dependency (on RTPS CPU nodes) */
        compatible = "simple-bus";
        ranges ;

        rpu_ctrl_bus_descend2 {
            compatible = "simple-bus";
            ranges ;

            rpu_ctrl_bus: rpu_ctrl_bus {
                compatible = "simple-bus";
                ranges ;

                /* TODO: to be replaced with Boeing design for reset controller */
                rpu_ctrl: rpu_control@0xff9a0000 {
                    gpio-controller;
                    #gpio-cells = <1>;
                    compatible = "xlnx,rpu-control";
                    reg = <0xff9a0000 0x400 /* prio = */ 0>;
                    atcm1-for-rpu0 = <&atcm1_for_rpu0>;
                    btcm1-for-rpu0 = <&btcm1_for_rpu0>;
                    icache-for-rpu1 = <&icache_rpu1>;
                    dcache-for-rpu1 = <&dcache_rpu1>;
                    ddr-mem-for-rpu = <&ddr_memory_2_for_rpu>;
                    gic-for-rpu = <&rtps_gic>;
                };
            };
        };
    };

    apu_bus: apu_bus {
        compatible = "simple-bus";
        ranges ;

        /* TODO: Xilinx-specific? Needed by ATF/Linux */
        apu: apu@0xfd5c0000 {
            compatible = "xlnx,apu";
            #gpio-cells = <1>;
            reg = <0xfd5c0000 0x1000 /* prio= */ 0x0>;
            cpu0 = <&hpps_cpu0>;
            cpu1 = <&hpps_cpu1>;
            cpu2 = <&hpps_cpu2>;
            cpu3 = <&hpps_cpu3>;

            /* APU GPIO outputs:
                  wfi_out   *4 (NOT connected)
                  PWRDWNREQ *4 (connected to NCPUHALT input of HPPS CPUs)
                  VINITHI   *4 (connected to VINITHI input of HPPS CPUs)
             */
        };

        /* TODO: Xilinx-specific? Needed by ATF/Linux */
        apu1: apu1@0xfd5c1000 {
            compatible = "xlnx,apu";
            #gpio-cells = <1>;
            reg = <0xfd5c1000 0x1000 /* prio= */ 0x0>;
            cpu0 = <&hpps_cpu4>;
            cpu1 = <&hpps_cpu5>;
            cpu2 = <&hpps_cpu6>;
            cpu3 = <&hpps_cpu7>;
        };
    };

    hpps: hpps { /* view of address space from HPPS CPUs */
        #address-cells = <2>;
        #size-cells = <2>;
        compatible = "simple-bus";
        ranges ;

        hpps_gic: interrupt-controller@0xf9000000 {
                #address-cells = <0>;
                #size-cells = <0>;
                #priority-cells = <0>;
                #interrupt-cells = <3>;
                #gpio-cells = <0>;
                #redistributor-regions = <1>;

                compatible = "arm,arm-gicv3";
                revision = <3>;

                /* Addr Bits = 18 + log2(#cores) = 21 (see GIC-500 TRM Section 3.2) */
                reg = <0x0 0xf9000000  0x0 0x10000  /* prio = */ 0x0   /* GICD */
                       0x0 0xf9100000  0x0 0x100000 /* prio = */ 0x0>; /* GICR */
                interrupt-controller ;
                num-irq = <320>;
                interrupts-extended = /* signals output by the interrupt controller */
                        /* IRQ * #cpus; each wired to input signal 0=IRQ on each CPU */
                        <&hpps_cpu0 0>, <&hpps_cpu1 0>, <&hpps_cpu2 0>, <&hpps_cpu3 0>,
                        <&hpps_cpu4 0>, <&hpps_cpu5 0>, <&hpps_cpu6 0>, <&hpps_cpu7 0>,
                        /* FIQ * #cpus, each wired to input signal 1=FIQ on each CPU */
                        <&hpps_cpu0 1>, <&hpps_cpu1 1>, <&hpps_cpu2 1>, <&hpps_cpu3 1>,
                        <&hpps_cpu4 1>, <&hpps_cpu5 1>, <&hpps_cpu6 1>, <&hpps_cpu7 1>,
                        /* vIRQ * #cpus, each wired to input signal 2=vIRQ on each CPU */
                        <&hpps_cpu0 2>, <&hpps_cpu1 2>, <&hpps_cpu2 2>, <&hpps_cpu3 2>,
                        <&hpps_cpu4 2>, <&hpps_cpu5 2>, <&hpps_cpu6 2>, <&hpps_cpu7 2>,
                        /* vFIQ * #cpus, each wired to input signal 3=vFIQ on each CPU */
                        <&hpps_cpu0 3>, <&hpps_cpu1 3>, <&hpps_cpu2 3>, <&hpps_cpu3 3>,
                        <&hpps_cpu4 3>, <&hpps_cpu5 3>, <&hpps_cpu6 3>, <&hpps_cpu7 3>,
                        /* maintanance * #cpus: each wired to a set of inputs on this interrupt controller */
                            /* inputs into this interrupt controller:
                                       [0 .. num-irq-1]: SPI
                                       [num-irq * cpuidx .. num-irq * cpuidx + 32]: PPI for CPU# cpuidx ( * #cpus )
                               set of input irq# = { num-irq - 16 + idx + 32*cpuidx | foreach cpuidx set in bitmask }

                                   0(SPI)|1(PPI)    idx    bit[31:8]=bitmask of cpu set (i.e. of inputs in PPI range for each CPU) */
                        <&hpps_gic 0x1              0x9    0x0100>,
                        <&hpps_gic 0x1              0x9    0x0200>,
                        <&hpps_gic 0x1              0x9    0x0400>,
                        <&hpps_gic 0x1              0x9    0x0800>,
                        <&hpps_gic 0x1              0x9    0x1000>,
                        <&hpps_gic 0x1              0x9    0x2000>,
                        <&hpps_gic 0x1              0x9    0x4000>,
                        <&hpps_gic 0x1              0x9    0x8000>;

                cpu-start-id = <3>;
                num-cpu = <8>;
        };

        csu_core@0xffca0000 { /* TODO: present in Chiplet? Probably, not. ATF wants this. */
            compatible = "xlnx,zynqmp-csu-core";
            reg = <0x0 0xffca0000 0x0 0x100 /* prio = */ 0x1>;
        };

        /* TODO: both of these IPI nodes will go away once PSCI-via-TRCH is implemented */
        ipibuf_ram: ipibuf@ff990000 {
                compatible = "qemu:memory-region";
                qemu,ram = <1>;
                reg = <0x0 0xff990000 0x0 0x1000 /* prio = */ 0x1>;
        };
        apu_ipi: apu_ipi@0xff300000 {
            compatible = "xlnx,zynqmp_ipi";
            gpio-controller;
            reg = <0x0 0xff300000 0x0 0x1000 /* prio = */ 0x1>;
            #gpio-cells = <2>;
            interrupts = <0>;
            interrupt-map = <0 0 0 &hpps_gic  GIC_SPI APU_IPI0_IRQ_0 GIC_LVL_HI>;
            interrupt-map-mask = <0 0 0xffff>;
            num-gpios = <64>;
            interrupt-gpios = <&apu_ipi 0 0>;
            gpios = <&apu_ipi 32 0>;
        };

        to_hpps_wdt { /* A wormhole in HW, there's no path to nic1 */
            compatible = "qemu:memory-region";
            alias = <&hpps_wdts>;
            reg = <0x0 0xfff70000 0x0 0x80000 /* prio = 0 */ 0x0>;
        };

        /* TODO: crf and crl will go away once TRCH reset controller is implemented */
        to_crf_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crf_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_crl_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&crl_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };
        to_apu_bus { /* TODO: temporary hack, because both TRCH and HPPS need this */
            compatible = "qemu:memory-region";
            alias = <&apu_bus>;
            reg = <0x0 0x0 0x0 0xFFFFFFFF /* prio = -2 */ 0xfffffffe>;
        };


        pmu_global: pmu_global@0xffd80000 {
            compatible = "xlnx,pmu_global";
            reg = <0x0 0xffd80000 0x0 0x40000 /* prio= */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
            num-gpios = <30>; /* pmu_global_client_gpios(30), pmu_global_controller_gpios(3 or 4) in xilinx_zynqmp_pmu_global.c */
            ignore-pwr-req = <1>;
        };

        to_ccn {
            compatible = "qemu:memory-region";
            alias = <&ccn>;
            reg = <0x0 0x0 /* size = */ 0xFFFFFFFF 0xFFFFFFFF /* prio = -1 */ 0xfffffffe>;
        };
    };

    rtps_wdts: rtps_wdts { /* accessible from TRCH nic1 and from RTPS */
        compatible = "simple-bus";
        ranges ;
        rtps_wdt0: wdt@0x0 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x0 0x1000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &rtps_gic GIC_PPI WDT_PPI_IRQ 0x0108>,
                               <0 0 1 &trch_nvic WDT_RTPS0_ST2_IRQ>;
        };
        rtps_wdt1: wdt@0x1000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x1000 0x1000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &rtps_gic GIC_PPI WDT_PPI_IRQ 0x0208>,
                               <0 0 1 &trch_nvic WDT_RTPS1_ST2_IRQ>;
        };
    };

    hpps_wdts: hpps_wdts { /* accessible from TRCH nic1 and from HPPS */
        compatible = "simple-bus";
        ranges ;
        hpps_wdt0: wdt@0x0 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x0 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x0108>,
                               <0 0 1 &trch_nvic WDT_HPPS0_ST2_IRQ>;
        };
        hpps_wdt1: wdt@0x10000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x10000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x0208>,
                               <0 0 1 &trch_nvic WDT_HPPS1_ST2_IRQ>;
        };
        hpps_wdt2: wdt@0x20000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x20000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x0408>,
                               <0 0 1 &trch_nvic WDT_HPPS2_ST2_IRQ>;
        };
        hpps_wdt3: wdt@0x30000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x30000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x0808>,
                               <0 0 1 &trch_nvic WDT_HPPS3_ST2_IRQ>;
        };
        hpps_wdt4: wdt@0x40000  {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x40000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x1008>,
                               <0 0 1 &trch_nvic WDT_HPPS4_ST2_IRQ>;
        };
        hpps_wdt5: wdt@0x50000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x50000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x2008>,
                               <0 0 1 &trch_nvic WDT_HPPS5_ST2_IRQ>;
        };
        hpps_wdt6: wdt@0x60000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x60000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x4008>,
                               <0 0 1 &trch_nvic WDT_HPPS6_ST2_IRQ>;
        };
        hpps_wdt7: wdt@0x70000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x70000 0x10000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &hpps_gic GIC_PPI WDT_PPI_IRQ 0x8008>,
                               <0 0 1 &trch_nvic WDT_HPPS7_ST2_IRQ>;
        };
    };

    nic1: nic1 {
        compatible = "simple-bus";
        ranges ;

        trch_sram: trch_sram@0x00000000 { /* TODO: could this also be accessed over I-/D-Code bus?
                                             If so, then we should move the definition one level
                                             above and add aliases to both here nic1{} and trch{}  */
            compatible = "qemu:memory-region";
            qemu,ram = <1>;
            reg = <0x00000000 0x100000 /* prio = */ 0x1>;
        };

        trch_dma_memattr: trch_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <1>;
            master-id = <MASTER_ID_TRCH_DMA>;
        };

        trch_dma: dma-controller@0x21000000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0x21000000 0x1000 /* prio= */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &trch_nvic TRCH_DMA_ABORT_IRQ>,
                            <0 0 1 &trch_nvic TRCH_DMA_EV0_IRQ>; /* count must match num_events */
            #dma-cells = <1>;
            dma = <&nic1>;
            memattr = <&trch_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <0>; /* boot into secure mode */
        };

        arm-generic-timer-system-counter@0x21001000 { /* TODO: replace with HPSC Elapsed Timer */
            /* The System Counter: the memory-mapped part of the ARM Generic Timers */
            compatible = "arm.generic-timer";
            reg = <0x21001000 0x1000 /* prio = */ 0x0>;
        };

        /* TODO: update addresses once defined in HW mem map */
        trch_wdt: wdt@0x21002000 {
            compatible = "hpsc,hpsc-wdt";
            reg = <0x21002000 0x1000 /* prio = */ 0x0>;
            gpio-controller;
            #gpio-cells = <1>;
            /* GPIO outputs: LAST_TIMEOUT */

            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =    <0 0 0 &trch_nvic WDT_TRCH_ST1_IRQ>
                               /* stage two not wired to NVIC, since LAST_TIMEOUT is wired */;
        };

        to_rtps_wdt {
            compatible = "qemu:memory-region";
            alias = <&rtps_wdts>;
            reg = <0x21003000 0x2000 /* prio = 0 */ 0x0>;
        };

        to_hpps_wdt {
            compatible = "qemu:memory-region";
            alias = <&hpps_wdts>;
            reg = <0x21010000 0x80000 /* prio = 0 */ 0x0>;
        };

        to_nic2 {
            compatible = "qemu:memory-region";
            alias = <&nic2>;
            reg = <0x38000000 0x1000 /* prio = */ 0x0>;
        };

        to_nic5 {
            compatible = "qemu:memory-region";
            alias = <&nic5>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    nic2: nic2 {
        compatible = "simple-bus";
        ranges ;

        /* TODO: RTPS SPI */

        to_nic3 {
            compatible = "qemu:memory-region";
            alias = <&nic3>;
            reg = <0x0 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
            
    };

    rtps_smmu_tbu0: rtps_smmu_tbu@0 { compatible = "simple-bus"; ranges ; };
    rtps_smmu_tbu1: rtps_smmu_tbu@1 { compatible = "simple-bus"; ranges ; };

    nic3: nic3 {
        compatible = "simple-bus";
        ranges ;

        rtps_ddr_low: rtps_ddr_low@0x40000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x40000000 0x40000000 /* prio= */ 0x0>;
        };

        rtps_smmu: rtps_smmu@0x31000000 {
            compatible = "arm,mmu-500";
            reg-extended = <&nic3 0x31000000    0x20000    /* prio= */ 0x0
                            &rtps_smmu_tbu0 0x0 0xffffffff /* prio= */ 0x0
                            &rtps_smmu_tbu1 0x0 0xffffffff /* prio= */ 0x0>;

            interrupts = <0 /* global irq */
                          1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16>; /* context irqs (16 contexts hardcoded in model */
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &rtps_gic GIC_SPI 186 GIC_LVL_HI>,
                            <0 0  1 &rtps_gic GIC_SPI 187 GIC_LVL_HI>,
                            <0 0  2 &rtps_gic GIC_SPI 188 GIC_LVL_HI>,
                            <0 0  3 &rtps_gic GIC_SPI 155 GIC_LVL_HI>,
                            <0 0  4 &rtps_gic GIC_SPI 189 GIC_LVL_HI>,
                            <0 0  5 &rtps_gic GIC_SPI 157 GIC_LVL_HI>,
                            <0 0  6 &rtps_gic GIC_SPI 191 GIC_LVL_HI>,
                            <0 0  7 &rtps_gic GIC_SPI 192 GIC_LVL_HI>,
                            <0 0  8 &rtps_gic GIC_SPI 193 GIC_LVL_HI>,
                            <0 0  9 &rtps_gic GIC_SPI 194 GIC_LVL_HI>,
                            <0 0 10 &rtps_gic GIC_SPI 195 GIC_LVL_HI>,
                            <0 0 11 &rtps_gic GIC_SPI 196 GIC_LVL_HI>,
                            <0 0 12 &rtps_gic GIC_SPI 197 GIC_LVL_HI>,
                            <0 0 13 &rtps_gic GIC_SPI 198 GIC_LVL_HI>,
                            <0 0 14 &rtps_gic GIC_SPI 199 GIC_LVL_HI>,
                            <0 0 15 &rtps_gic GIC_SPI 200 GIC_LVL_HI>,
                            <0 0 16 &rtps_gic GIC_SPI 202 GIC_LVL_HI>;

            /* dma:  points to the MR used for PTWs.  */
            dma = <&nic3>;
            /* mr-x: points to the per TBU down-stream MR.  */
            mr-0 = <&nic3>;
            mr-1 = <&nic3>;
        };

        rtps_dma_memattr: rtps_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <1>;
            master-id = <MASTER_ID_RTPS_DMA>;
        };

        /* TODO: non-secure APB iface is at 0x30a09000: another node? */
        rtps_dma: dma-controller@0x30a08000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0x30a08000 0x1000 /* prio= */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &rtps_gic GIC_SPI RTPS_DMA_ABORT_IRQ GIC_LVL_HI>,
                            <0 0 1 &rtps_gic GIC_SPI RTPS_DMA_EV0_IRQ   GIC_LVL_HI>;
            #dma-cells = <1>;
            dma = <&rtps_smmu_tbu0>;
            memattr = <&rtps_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <0>; /* boot into secure mode */
        };

        /* TODO: PCIe (dma = <&rtps_smmu_tbu1>) */

        to_nic5 {
            compatible = "qemu:memory-region";
            alias = <&nic5>;
            reg = <0x0 0xffffffff /* prio */ 0xffffffff /* -1 */>;
        };
    };

    nic4: nic4 { /* lsio */
        compatible = "simple-bus";
        ranges ;

        lsio_mailbox: mailbox@0x3000a000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &trch_nvic 72>, <0 0  0 &rtps_gic GIC_SPI 72 GIC_LVL_HI>,
                            <0 0  1 &trch_nvic 73>, <0 0  1 &rtps_gic GIC_SPI 73 GIC_LVL_HI>,
                            <0 0  2 &trch_nvic 74>, <0 0  2 &rtps_gic GIC_SPI 74 GIC_LVL_HI>,
                            <0 0  3 &trch_nvic 75>, <0 0  3 &rtps_gic GIC_SPI 75 GIC_LVL_HI>,
                            <0 0  4 &trch_nvic 76>, <0 0  4 &rtps_gic GIC_SPI 76 GIC_LVL_HI>,
                            <0 0  6 &trch_nvic 77>, <0 0  6 &rtps_gic GIC_SPI 77 GIC_LVL_HI>,
                            <0 0  7 &trch_nvic 76>, <0 0  7 &rtps_gic GIC_SPI 76 GIC_LVL_HI>,
                            <0 0  8 &trch_nvic 77>, <0 0  8 &rtps_gic GIC_SPI 77 GIC_LVL_HI>,
                            <0 0  9 &trch_nvic 78>, <0 0  9 &rtps_gic GIC_SPI 78 GIC_LVL_HI>,
                            <0 0 10 &trch_nvic 79>, <0 0 10 &rtps_gic GIC_SPI 79 GIC_LVL_HI>,
                            <0 0 11 &trch_nvic 80>, <0 0 11 &rtps_gic GIC_SPI 80 GIC_LVL_HI>,
                            <0 0 12 &trch_nvic 81>, <0 0 12 &rtps_gic GIC_SPI 81 GIC_LVL_HI>,
                            <0 0 13 &trch_nvic 82>, <0 0 13 &rtps_gic GIC_SPI 82 GIC_LVL_HI>,
                            <0 0 14 &trch_nvic 83>, <0 0 14 &rtps_gic GIC_SPI 83 GIC_LVL_HI>,
                            <0 0 15 &trch_nvic 84>, <0 0 15 &rtps_gic GIC_SPI 84 GIC_LVL_HI>;

            reg = <0x3000a000 0x1000 /* prio = */ 0x0>;
        };

        lsio_uart_0: serial@0x30000000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0x30000000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <0>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &trch_nvic LSIO_UART0_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

        lsio_uart_1: serial@0x30001000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0x30001000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <0>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &trch_nvic LSIO_UART1_IRQ_0>;
            port-number = <0>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

        trch_smc353: trch_smc353@0x30009000{
            arm,addr25 = <0x0>;
            clock-names = "memclk", "aclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "arm,pl35x";
            reg = <0x30009000 0x1000 /* prio = */ 0x0>;
            interrupts = <0>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map =  <0 0 0 &trch_nvic TRCH_SMC_IRQ>;
            x = <3>;
            ranges ;
	    trch_offchip_sram0: trch_offchip_sram0@0x28000000 {
		compatible = "offchip-sram";
	  	#address-cells = <2>;
		#size-cells = <2>;
		reg   = <0x0 0x28000000 0x0 0x4000000>;
		drive = "";
                status = "disabled";
		start_addr_high = <0x0>;
		start_addr_low= <0x28000000>;
		region_size = <0x04000000>;
		pflash_index = <0>;
	    };
        };
            /* TODO: GPIO */
            /* TODO: I2C */
            /* TODO: SPI */
    };

    nic5: nic5 {
        compatible = "simple-bus";
        ranges ;

        /* {RTPS,TRCH} -> HPPS MMU */
        rt_smmu: smmu0@0x31100000 {
            compatible = "arm,mmu-500";
            reg-extended = <&nic5 0x31100000 0x20000     /* prio = */ 0x0
                            &nic5 0          0xffffffff  /* prio = */ 0xfffffffe>; /* master connected to slave interface of MMU */

            interrupts = <0 /* global irq */
                          1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16>; /* context irqs (16 contexts hardcoded in model) */
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &trch_nvic 169>,
                            <0 0  1 &trch_nvic 170>,
                            <0 0  2 &trch_nvic 171>,
                            <0 0  3 &trch_nvic 172>,
                            <0 0  4 &trch_nvic 173>,
                            <0 0  5 &trch_nvic 174>,
                            <0 0  6 &trch_nvic 175>,
                            <0 0  7 &trch_nvic 176>,
                            <0 0  8 &trch_nvic 177>,
                            <0 0  9 &trch_nvic 178>,
                            <0 0 10 &trch_nvic 179>,
                            <0 0 11 &trch_nvic 180>,
                            <0 0 12 &trch_nvic 181>,
                            <0 0 13 &trch_nvic 182>,
                            <0 0 14 &trch_nvic 183>,
                            <0 0 15 &trch_nvic 184>,
                            <0 0 16 &trch_nvic 185>;

            /* dma:  points to the MR used for PTWs.  */
            /* mr-x: points to the per TBU down-stream MR.  */
            dma = <&ccn>;
            mr-0 = <&ccn>;
        };

        to_nic4 { /* lsio */
                compatible = "qemu:memory-region";
                alias = <&nic4>;
                /* reg = <0x30000000 0x3000b0000 * prio = * 0x0>; */
                reg = <0x0 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
    };

    mdio0: mdio {
        #address-cells = <1>;
        #size-cells = <0>;
        compatible="mdio";
        phy0: phy@7 {
            compatible = "88e1118r";
            device_type = "ethernet-phy";
            reg = <7>;
        };
    };

    hpps_smmu_tbu0: hpps_smmu_tbu@0 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu1: hpps_smmu_tbu@1 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu2: hpps_smmu_tbu@2 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu3: hpps_smmu_tbu@3 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu4: hpps_smmu_tbu@4 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu5: hpps_smmu_tbu@5 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu6: hpps_smmu_tbu@6 { compatible = "simple-bus"; ranges ; };
    hpps_smmu_tbu7: hpps_smmu_tbu@7 { compatible = "simple-bus"; ranges ; };

    nic6: nic6 {
        compatible = "simple-bus";
        ranges ;

        hpps_trch_mailbox: mailbox@0xfff50000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &hpps_gic GIC_SPI 136 GIC_LVL_HI>, <0 0  0 &trch_nvic 136>,
                            <0 0  1 &hpps_gic GIC_SPI 137 GIC_LVL_HI>, <0 0  1 &trch_nvic 137>,
                            <0 0  2 &hpps_gic GIC_SPI 138 GIC_LVL_HI>, <0 0  2 &trch_nvic 138>,
                            <0 0  3 &hpps_gic GIC_SPI 139 GIC_LVL_HI>, <0 0  3 &trch_nvic 139>,
                            <0 0  4 &hpps_gic GIC_SPI 140 GIC_LVL_HI>, <0 0  4 &trch_nvic 140>,
                            <0 0  6 &hpps_gic GIC_SPI 141 GIC_LVL_HI>, <0 0  6 &trch_nvic 141>,
                            <0 0  7 &hpps_gic GIC_SPI 142 GIC_LVL_HI>, <0 0  7 &trch_nvic 142>,
                            <0 0  8 &hpps_gic GIC_SPI 143 GIC_LVL_HI>, <0 0  8 &trch_nvic 143>,
                            <0 0  9 &hpps_gic GIC_SPI 144 GIC_LVL_HI>, <0 0  9 &trch_nvic 144>,
                            <0 0 10 &hpps_gic GIC_SPI 145 GIC_LVL_HI>, <0 0 10 &trch_nvic 145>,
                            <0 0 11 &hpps_gic GIC_SPI 146 GIC_LVL_HI>, <0 0 11 &trch_nvic 146>,
                            <0 0 12 &hpps_gic GIC_SPI 147 GIC_LVL_HI>, <0 0 12 &trch_nvic 147>,
                            <0 0 13 &hpps_gic GIC_SPI 148 GIC_LVL_HI>, <0 0 13 &trch_nvic 148>,
                            <0 0 14 &hpps_gic GIC_SPI 149 GIC_LVL_HI>, <0 0 14 &trch_nvic 149>,
                            <0 0 15 &hpps_gic GIC_SPI 150 GIC_LVL_HI>, <0 0 15 &trch_nvic 150>;

            reg = <0xfff50000 0x1000 /* prio = */ 0x0>;
        };

        hpps_rtps_mailbox: mailbox@0xfff60000 {
            compatible = "hpsc,hpsc-mbox";
            interrupts = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &hpps_gic GIC_SPI 203 GIC_LVL_HI>, <0 0  0 &rtps_gic GIC_SPI 203 GIC_LVL_HI>,
                            <0 0  1 &hpps_gic GIC_SPI 204 GIC_LVL_HI>, <0 0  1 &rtps_gic GIC_SPI 204 GIC_LVL_HI>,
                            <0 0  2 &hpps_gic GIC_SPI 205 GIC_LVL_HI>, <0 0  2 &rtps_gic GIC_SPI 205 GIC_LVL_HI>,
                            <0 0  3 &hpps_gic GIC_SPI 206 GIC_LVL_HI>, <0 0  3 &rtps_gic GIC_SPI 206 GIC_LVL_HI>,
                            <0 0  4 &hpps_gic GIC_SPI 207 GIC_LVL_HI>, <0 0  4 &rtps_gic GIC_SPI 207 GIC_LVL_HI>,
                            <0 0  6 &hpps_gic GIC_SPI 208 GIC_LVL_HI>, <0 0  6 &rtps_gic GIC_SPI 208 GIC_LVL_HI>,
                            <0 0  7 &hpps_gic GIC_SPI 209 GIC_LVL_HI>, <0 0  7 &rtps_gic GIC_SPI 209 GIC_LVL_HI>,
                            <0 0  8 &hpps_gic GIC_SPI 210 GIC_LVL_HI>, <0 0  8 &rtps_gic GIC_SPI 210 GIC_LVL_HI>,
                            <0 0  9 &hpps_gic GIC_SPI 211 GIC_LVL_HI>, <0 0  9 &rtps_gic GIC_SPI 211 GIC_LVL_HI>,
                            <0 0 10 &hpps_gic GIC_SPI 212 GIC_LVL_HI>, <0 0 10 &rtps_gic GIC_SPI 212 GIC_LVL_HI>,
                            <0 0 11 &hpps_gic GIC_SPI 213 GIC_LVL_HI>, <0 0 11 &rtps_gic GIC_SPI 213 GIC_LVL_HI>,
                            <0 0 12 &hpps_gic GIC_SPI 214 GIC_LVL_HI>, <0 0 12 &rtps_gic GIC_SPI 214 GIC_LVL_HI>,
                            <0 0 13 &hpps_gic GIC_SPI 215 GIC_LVL_HI>, <0 0 13 &rtps_gic GIC_SPI 215 GIC_LVL_HI>,
                            <0 0 14 &hpps_gic GIC_SPI 216 GIC_LVL_HI>, <0 0 14 &rtps_gic GIC_SPI 216 GIC_LVL_HI>,
                            <0 0 15 &hpps_gic GIC_SPI 217 GIC_LVL_HI>, <0 0 15 &rtps_gic GIC_SPI 217 GIC_LVL_HI>;

            reg = <0xfff60000 0x1000 /* prio = */ 0x0>;
        };

        hpps_uart_0: serial@0xf92c0000 {
            compatible = "xlnx,ps7-uart-1.00.a", "xlnx,xuartps";
            reg = <0xf92c0000 0x1000 /* prio = */ 0x0>;
            current-speed = <115200>;
            interrupts = <0>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI HPPS_UART0_IRQ_0 GIC_LVL_HI>;
            port-number = <1>;
            xlnx,has-modem = <0x0>;
            xlnx,uart-clk-freq-hz = <50000000>;
            clock-names = "uart_clk", "pclk";
            clocks = <&uart_clk &uart_clk>;
            ttrig-polarity = <1>;
        };

        hpps_smc353: hpps_smc353@0xf92d0000 {
            arm,addr25 = <0x0>;
            clock-names = "memclk", "aclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "arm,pl35x";
            reg = <0xf92d0000 0x1000 /* prio = */ 0x0>;
            interrupts = <0>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI HPPS_SMC_IRQ GIC_LVL_HI>;
            x = <3>;
            ranges ;
	    hpps_sram0: hpps_sram0@0x680000000 {
		compatible = "offchip-sram";
	  	#address-cells = <2>;
		#size-cells = <2>;
		reg   = <0x6 0x80000000 0x0 0x40000000>;
		drive = "";
                status = "disabled";
		start_addr_high = <0x6>;
		start_addr_low= <0x80000000>;
		region_size = <0x80000000>;
		pflash_index = <2>;
	    };
            hpps_nand0: hpps_nand0@0x600000000 {
                compatible = "nand";
                arm,nand-cycle-t0 = <0x4>;
                arm,nand-cycle-t1 = <0x4>;
                arm,nand-cycle-t2 = <0x1>;
                arm,nand-cycle-t3 = <0x2>;
                arm,nand-cycle-t4 = <0x2>;
                arm,nand-cycle-t5 = <0x2>;
                arm,nand-cycle-t6 = <0x4>;
                chip_id = <0xaa>;
                manufacturer_id = <0x2c>;
                drive = "";
                label = "nand0";
                status = "disabled";
                reg = <0x6 0x00000000 0x0 0x10000000 /* prio = 0 */ 0x0>;
		start_addr_high = <0x6>;
		start_addr_low= <0x00000000>;
		region_size = <0x80000000>;
		pflash_index = <3>;
                #address-cells = <0x2>;
                #size-cells = <0x2>;
            };
        };

        hpps_smmu: smmu@0xf9300000 {
                compatible = "arm,mmu-500";
                reg-extended = <&nic6 0xf9300000  0x20000     /* prio = */ 0x0
                                &hpps_smmu_tbu0 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu1 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu2 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu3 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu4 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu5 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu6 0 0xffffffff  /* prio = */ 0x0
                                &hpps_smmu_tbu7 0 0xffffffff  /* prio = */ 0x0>;

            interrupts = <0 /* global irq */
                          1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16>; /* context irqs (16 contexts hardcoded in model) */
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0  0 &hpps_gic GIC_SPI 152 GIC_LVL_HI>,
                            <0 0  1 &hpps_gic GIC_SPI 153 GIC_LVL_HI>,
                            <0 0  2 &hpps_gic GIC_SPI 154 GIC_LVL_HI>,
                            <0 0  3 &hpps_gic GIC_SPI 155 GIC_LVL_HI>,
                            <0 0  4 &hpps_gic GIC_SPI 156 GIC_LVL_HI>,
                            <0 0  5 &hpps_gic GIC_SPI 157 GIC_LVL_HI>,
                            <0 0  6 &hpps_gic GIC_SPI 158 GIC_LVL_HI>,
                            <0 0  7 &hpps_gic GIC_SPI 159 GIC_LVL_HI>,
                            <0 0  8 &hpps_gic GIC_SPI 160 GIC_LVL_HI>,
                            <0 0  9 &hpps_gic GIC_SPI 161 GIC_LVL_HI>,
                            <0 0 10 &hpps_gic GIC_SPI 162 GIC_LVL_HI>,
                            <0 0 11 &hpps_gic GIC_SPI 163 GIC_LVL_HI>,
                            <0 0 12 &hpps_gic GIC_SPI 164 GIC_LVL_HI>,
                            <0 0 13 &hpps_gic GIC_SPI 165 GIC_LVL_HI>,
                            <0 0 14 &hpps_gic GIC_SPI 166 GIC_LVL_HI>,
                            <0 0 15 &hpps_gic GIC_SPI 167 GIC_LVL_HI>,
                            <0 0 16 &hpps_gic GIC_SPI 168 GIC_LVL_HI>;

                /* dma:  points to the MR used for PTWs.  */
                dma = <&nic7>;

                /* mr-x: points to the per TBU down-stream MR.  */
                mr-0 = <&nic7>; /* DMA */
                mr-1 = <&nic7>; /* PCIe */
                mr-2 = <&nic7>; /* Ethernet */
                mr-3 = <&nic7>; /* TTE */
                mr-4 = <&nic7>; /* SRIO DMA 0 */
                mr-5 = <&nic7>; /* SRIO DMA 1 */
                mr-6 = <&nic7>; /* SRIO EP 0 */
                mr-7 = <&nic7>; /* SRIO EP 1 */
        };

        hpps_dma_memattr: hpps_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_HPPS_DMA>;
        };

        /* TODO: secure at 0xf92f0000: another node? */
        hpps_dma: dma-controller@0xf92e0000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xf92e0000 0x1000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI HPPS_DMA_ABORT_IRQ GIC_LVL_HI>,
                            <0 0 1 &hpps_gic GIC_SPI HPPS_DMA_EV0_IRQ   GIC_LVL_HI>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu0>;
            memattr = <&hpps_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        srio0_dma_memattr: srio0_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_SRIO0_DMA>;
        };

        /* TODO: secure at 0xe5320000: another node? */
        srio0_dma: dma-controller@0xe5310000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xe5310000 0x1000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI SRIO0_DMA_ABORT_IRQ GIC_LVL_HI>,
                            <0 0 1 &hpps_gic GIC_SPI SRIO0_DMA_EV0_IRQ   GIC_LVL_HI>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu4>;
            memattr = <&srio0_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        srio1_dma_memattr: srio1_dma_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_SRIO1_DMA>;
        };

        /* TODO: secure at 0xe5340000: another node? */
        srio1_dma: dma-controller@0xe5330000 {
            compatible = "arm,pl330", "arm,primecell";
            reg = <0xe5330000 0x1000 /* prio = */ 0x0>;
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI SRIO1_DMA_ABORT_IRQ GIC_LVL_HI>,
                            <0 0 1 &hpps_gic GIC_SPI SRIO1_DMA_EV0_IRQ   GIC_LVL_HI>;
            #dma-cells = <1>;
            dma = <&hpps_smmu_tbu5>;
            memattr = <&srio1_dma_memattr>;
            num_chnls  = <1>;
            num_events = <1>;
            num_periph_req = <0>;
            mgr_ns_at_rst = <1>; /* boot into non-secure mode */
            INS = <0xffffffff>; /* mark all events as non-secure */
            PNS = <0xffffffff>; /* mark all periphs as non-secure */
        };

        xgmac_memattr: xgmac_memattr@0 {
            compatible = "qemu:memory-transaction-attr";
            secure = <0>;
            master-id = <MASTER_ID_XGMAC>;
        };
        xgmac: ethernet@0xe5300000 {
            #stream-id-cells = <0x1>;
            #address-cells = <1>;
            #size-cells = <0>;
            #priority-cells = <0>;
            reg = <0xe5300000 0x1000 /* prio = */ 0x0>;
            clock-names = "hclk", "pclk";
            clocks = <&misc_clk>, <&misc_clk>;
            compatible = "xlnx,ps7-ethernet-1.00.a", "cdns,gem";  /* TODO: change to Synopsys DWC_ether */
            interrupts = <0 1>;
            interrupt-map-mask = <0 0 0xffff>;
            interrupt-map = <0 0 0 &hpps_gic GIC_SPI XGMAC_IRQ_0      GIC_LVL_HI>,
                            <0 0 1 &hpps_gic GIC_SPI XGMAC_IRQ_1_WAKE GIC_LVL_HI>;
            dma = <&hpps_smmu_tbu2>;
            memattr = <&xgmac_memattr>;
            local-mac-address = [00 0a 35 00 02 90];
            num-priority-queues = <1>;
            revision = <0x40070106>;
            mdio = <&mdio0>;
        };

        /* TODO: PCIe */
        /* TODO: Spacewire */
        /* TODO: TTE */
    };

    nic7: nic7 { /* HSIO goes through HPPS SMMU then through this NIC */
        #address-cells = <2>;
        #size-cells = <2>;

        compatible = "simple-bus";
        ranges ;

        to_ccn {
            compatible = "qemu:memory-region";
            alias = <&ccn>;
            reg = <0x0 0x0 /* size = */ 0xFFFFFFFF 0xFFFFFFFF /* prio = -1 */ 0xfffffffe>;
        };
    };

    ccn: ccn {
        #address-cells = <2>;
	#size-cells = <2>;    

        compatible = "simple-bus";
        ranges ;

        hpps_ddr_low: hpps_ddr_low@0x80000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x0 0x80000000 0x0 0x40000000 /* prio = */ 0x0>;
        };

        hpps_ddr_high0: hpps_ddr_high0@0x100000000 { /* TODO: TZC400 */
            compatible = "qemu:memory-region";
            device_type = "memory";
            qemu,ram = <1>;
            reg = <0x1 0x00000000 0x0 0x80000000 /* prio = */ 0x0>;
        };

        to_nic6 {
            compatible = "qemu:memory-region";
            alias = <&nic6>;
            /* reg = <0xF9220000 0x000C0000 * prio = -1 * 0xffffffff>; */ /* TODO: why does this not work? */
            reg = <0x0 0x0 0x6 0xffffffff /* prio = -1 */ 0xffffffff>;
        };
    };

    uart_clk: uart_clk {
        #clock-cells = <0>;
        clock-frequency = <25000000>;
        compatible = "fixed-clock";
    };

    misc_clk: misc_clk {
        #clock-cells = <0>;
        clock-frequency = <50000000>;
        compatible = "fixed-clock";
    };

    /* arm_generic_fdt insists on having a memory node at root: we won't use this */
    /* TODO: get rid of this */
    dummy_memory: memory {
        compatible = "qemu:memory-region";
        qemu,ram = <1>;
        reg = <0x0 0xffffffff /* prio = */ 0x0>;
    };
};
